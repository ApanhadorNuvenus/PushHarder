ALL MY TRAINING and ADD EDIT TRAINING FEATURE CODE:

package com.example.apptest

import android.app.Application
import dagger.hilt.android.HiltAndroidApp

// Don't forget tot specify this file ass appname in the manifest file!!!
// android:name=".TrainingApp"
@HiltAndroidApp
class TrainingApp : Application() {
}

<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <application
        android:name=".TrainingApp"
        android:allowBackup="true"
        android:dataExtractionRules="@xml/data_extraction_rules"
        android:fullBackupContent="@xml/backup_rules"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/Theme.AppTest"
        tools:targetApi="31">
        <activity
            android:name=".feature_train.presentation.MainActivity"
            android:exported="true"
            android:label="@string/app_name"
            android:theme="@style/Theme.AppTest">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />

                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
    </application>

</manifest>

package com.example.apptest.di

import android.app.Application
import androidx.room.Room
import com.example.apptest.feature_train.data.data_source.TrainDatabase
import com.example.apptest.feature_train.data.repository.FakeTrainingRepository
import com.example.apptest.feature_train.data.repository.TrainingRepositoryImpl
import com.example.apptest.feature_train.domain.repository.TrainingRepository
import com.example.apptest.feature_train.domain.use_case.training_use_case.AddTraining
import com.example.apptest.feature_train.domain.use_case.training_use_case.DeleteTraining
import com.example.apptest.feature_train.domain.use_case.training_use_case.GetAllTrainings
import com.example.apptest.feature_train.domain.use_case.training_use_case.GetTrainingById
import com.example.apptest.feature_train.domain.use_case.training_use_case.TrainingUseCases
import com.example.apptest.feature_train.domain.use_case.training_use_case.UpdateTraining
import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.components.SingletonComponent
import javax.inject.Singleton


@Module
@InstallIn(SingletonComponent::class)
object AppModule {

    @Provides
    @Singleton
    fun provideTrainDatabase(app: Application) : TrainDatabase{
        return Room.databaseBuilder(
            app,
            TrainDatabase::class.java,
            TrainDatabase.DATABASE_NAME
        ).build()
    }

    @Provides
    @Singleton
    fun provideTrainingRepository(db: TrainDatabase): TrainingRepository {
        // when database created an instance of trainingDao is created as well and consumed here
        return TrainingRepositoryImpl(db.trainingDao)
//        return FakeTrainingRepository()
    }

    @Provides
    @Singleton
    fun provideTrainingUseCases(repository: TrainingRepository) : TrainingUseCases {
        return TrainingUseCases(
            addTraining = AddTraining(repository),
            deleteTraining = DeleteTraining(repository),
            getAllTrainings = GetAllTrainings(repository),
            getTrainingById = GetTrainingById(repository),
            updateTraining = UpdateTraining(repository)
        )
    }
}

package com.example.apptest.feature_train.data.data_source

import androidx.room.Database
import androidx.room.RoomDatabase
import com.example.apptest.feature_train.domain.model.Training

@Database(
    entities = [Training::class],
    version = 1, // Simplified version
)
abstract class TrainDatabase : RoomDatabase() {
    abstract val trainingDao: TrainingDao

    companion object {
        const val DATABASE_NAME = "trainings_db"
    }
}


package com.example.apptest.feature_train.data.data_source

import androidx.room.Dao
import androidx.room.Delete
import androidx.room.Insert
import androidx.room.OnConflictStrategy
import androidx.room.Query
import androidx.room.Update
import com.example.apptest.feature_train.domain.model.Training
import kotlinx.coroutines.flow.Flow


@Dao
interface TrainingDao {
    @Query("SELECT * FROM Training")
    fun getAllTrainings(): Flow<List<Training>>

    @Query("SELECT * FROM Training WHERE id = :trainingId")
    suspend fun getTrainingById(trainingId: Int): Training? // Suspend function is correct here

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun addTraining(training: Training) // Suspend function is correct here

    @Update
    suspend fun updateTraining(training: Training) // Suspend function is correct here

    @Delete
    suspend fun deleteTraining(training: Training) // Suspend function is correct here
}


package com.example.apptest.feature_train.data.repository

import com.example.apptest.feature_train.data.data_source.TrainingDao
import com.example.apptest.feature_train.domain.model.Training
import com.example.apptest.feature_train.domain.repository.TrainingRepository
import kotlinx.coroutines.flow.Flow

class TrainingRepositoryImpl(
    private val dao: TrainingDao
) : TrainingRepository {

    override fun getAllTrainings(): Flow<List<Training>> {
        return dao.getAllTrainings()
    }

    override suspend fun getTrainingById(trainingId: Int): Training? {
        return dao.getTrainingById(trainingId)
    }

    override suspend fun addTraining(training: Training) {
        dao.addTraining(training)
    }

    override suspend fun updateTraining(training: Training) {
        dao.updateTraining(training)
    }

    override suspend fun deleteTraining(training: Training) {
        dao.deleteTraining(training)
    }
}


package com.example.apptest.feature_train.domain.model

import androidx.room.Entity
import androidx.room.PrimaryKey

@Entity
data class Training(
    val title: String,
    val date: Long,
    val failure: Boolean = false,
    val weights: Int? = null,
    @PrimaryKey(autoGenerate = true) val id: Int = 0 // Auto-generate ID
)

class InvalidTrainingException(message: String) : Exception(message)

package com.example.apptest.feature_train.domain.repository

import com.example.apptest.feature_train.domain.model.Training
import kotlinx.coroutines.flow.Flow

interface TrainingRepository {

    fun getAllTrainings(): Flow<List<Training>>

    suspend fun getTrainingById(trainingId: Int): Training?

    suspend fun addTraining(training: Training)

    suspend fun updateTraining(training: Training)

    suspend fun deleteTraining(training: Training)
}

package com.example.apptest.feature_train.domain.use_case.training_use_case

import com.example.apptest.feature_train.domain.model.InvalidTrainingException
import com.example.apptest.feature_train.domain.model.Training
import com.example.apptest.feature_train.domain.repository.TrainingRepository

class AddTraining(private val repository: TrainingRepository) {
    suspend operator fun invoke(training: Training) {
        // Check if title (name) is specified
        if (training.title.isBlank()) {
            throw InvalidTrainingException("Training name must not be empty.")
        }

        // Add the training to the repository
        repository.addTraining(training)
    }
}

package com.example.apptest.feature_train.domain.use_case.training_use_case

import com.example.apptest.feature_train.domain.model.Training
import com.example.apptest.feature_train.domain.repository.TrainingRepository

class DeleteTraining(private val repository: TrainingRepository) {
    suspend operator fun invoke(training: Training) {
        repository.deleteTraining(training)
    }
}

package com.example.apptest.feature_train.domain.use_case.training_use_case

import com.example.apptest.feature_train.domain.model.Training
import com.example.apptest.feature_train.domain.repository.TrainingRepository
import com.example.apptest.feature_train.domain.util.OrderType
import com.example.apptest.feature_train.domain.util.TrainingOrder
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map

class GetAllTrainings(private val repository: TrainingRepository) {
    operator fun invoke(
        //date by default
        noteOrder: TrainingOrder = TrainingOrder.Date(OrderType.Descending)
    ): Flow<List<Training>> {
        return repository.getAllTrainings().map {trainings ->
            when(noteOrder.orderType) {
                is OrderType.Ascending -> {
                    when(noteOrder) {
                        is TrainingOrder.Title -> trainings.sortedBy { it.title.lowercase() }
                        is TrainingOrder.Date -> trainings.sortedBy { it.date }
                    }
                }
                is OrderType.Descending -> {
                    when(noteOrder) {
                        is TrainingOrder.Title -> trainings.sortedByDescending { it.title.lowercase() }
                        is TrainingOrder.Date -> trainings.sortedByDescending { it.date }
                    }
                }
            }
        }
    }
}


package com.example.apptest.feature_train.domain.use_case.training_use_case

import com.example.apptest.feature_train.domain.model.Training
import com.example.apptest.feature_train.domain.repository.TrainingRepository

class GetTrainingById(private val repository: TrainingRepository) {
    suspend operator fun invoke(trainingId: Int): Training? {
        return repository.getTrainingById(trainingId)
    }
}

package com.example.apptest.feature_train.domain.use_case.training_use_case

data class TrainingUseCases(
    val addTraining: AddTraining,
    val deleteTraining: DeleteTraining,
    val getAllTrainings: GetAllTrainings,
    val getTrainingById: GetTrainingById,
    val updateTraining: UpdateTraining
)

package com.example.apptest.feature_train.domain.use_case.training_use_case

import com.example.apptest.feature_train.domain.model.Training
import com.example.apptest.feature_train.domain.repository.TrainingRepository

class UpdateTraining(private val repository: TrainingRepository) {
    suspend operator fun invoke(training: Training) {
        repository.updateTraining(training)
    }
}



package com.example.apptest.feature_train.presentation.trainings

import com.example.apptest.feature_train.domain.model.Training
import com.example.apptest.feature_train.domain.util.TrainingOrder


sealed class TrainingsEvent {
    // when order has changed
    data class Order(val trainingOrder: TrainingOrder): TrainingsEvent()
    // when training was deleted
    data class DeleteTraining (val training: Training): TrainingsEvent()
    // when snackbar showed user wish to undo delete
    object RestoreTraining: TrainingsEvent()
    // when orderSection is clicked to roll out
    object ToggleOrderSection: TrainingsEvent()
}

package com.example.apptest.feature_train.presentation.trainings

import androidx.compose.animation.AnimatedVisibility
import androidx.compose.animation.ExperimentalAnimationApi
import androidx.compose.animation.fadeIn
import androidx.compose.animation.fadeOut
import androidx.compose.animation.slideInVertically
import androidx.compose.animation.slideOutVertically
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.PaddingValues
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.Sort
import androidx.compose.material.icons.filled.Add
import androidx.compose.material.icons.filled.Sort
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.FloatingActionButton
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Scaffold
import androidx.compose.material3.SnackbarHost
import androidx.compose.material3.SnackbarHostState
import androidx.compose.material3.SnackbarResult
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.navigation.NavController
import com.example.apptest.feature_train.presentation.trainings.components.OrderSection
import com.example.apptest.feature_train.presentation.trainings.components.TrainingItem
import com.example.apptest.feature_train.presentation.util.Screen
import kotlinx.coroutines.launch

@OptIn(ExperimentalAnimationApi::class, ExperimentalMaterial3Api::class)
@Composable
fun TrainingsScreen(
    navController: NavController,
    viewModel: TrainingsViewModel = hiltViewModel()
) {
    // assigned viewmodel state to local layout objects
    val state = viewModel.state.value
    val scaffoldState = remember { SnackbarHostState() }
    val scope = rememberCoroutineScope()

    Scaffold(
        floatingActionButton = {
            FloatingActionButton(
                onClick = {
                    //TODO: navigation is not implemented yet
                    navController.navigate(Screen.AddEditTrainingScreen.route)
                },
                containerColor = MaterialTheme.colorScheme.primary
            ) {
                Icon(imageVector = Icons.Default.Add, contentDescription = "Add training")
            }
        },
        snackbarHost = { SnackbarHost(scaffoldState) }
    ) { innerPadding ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(innerPadding) // Apply the innerPadding provided by Scaffold
        ) {
            Row(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(16.dp),
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.CenterVertically
            ) {
                Text(
                    text = "Your trainings",
                    style = MaterialTheme.typography.headlineMedium
                )
                IconButton(
                    onClick = {
                        // changed the state of oredersection visibility to opposite
                        viewModel.onEvent(TrainingsEvent.ToggleOrderSection)
                    },
                ) {
                    Icon(
                        imageVector = Icons.AutoMirrored.Default.Sort,
                        contentDescription = "Sort"
                    )
                }
            }
            AnimatedVisibility(
                visible = state.isOrderSectionVisible,
                enter = fadeIn() + slideInVertically(),
                exit = fadeOut() + slideOutVertically()
            ) {
                OrderSection(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(16.dp),
                    trainingOrder = state.trainingOrder,
                    onOrderChange = {
                        // when any button of section pressed calls event in VM
                        viewModel.onEvent(TrainingsEvent.Order(it))
                    }
                )
            }
            Spacer(modifier = Modifier.height(16.dp))
            LazyColumn(modifier = Modifier.fillMaxSize().padding(horizontal = 16.dp)) {
                // takes trainings from outer, changed state
                items(state.trainings) { training ->
                    TrainingItem(
                        training = training,
                        modifier = Modifier
                            .fillMaxWidth()
                            .clickable {
                                //ToDo: navigation is not implemented yet
                                navController.navigate(
                                    Screen.AddEditTrainingScreen.route +
                                            "?trainingId=${training.id}"
                                )
                            },
                        onDeleteClick = {
                            viewModel.onEvent(TrainingsEvent.DeleteTraining(training))
                            scope.launch {
                                val result = scaffoldState.showSnackbar(
                                    message = "Training deleted",
                                    actionLabel = "Undo"
                                )
                                if (result == SnackbarResult.ActionPerformed) {
                                    viewModel.onEvent(TrainingsEvent.RestoreTraining)
                                }
                            }
                        }
                    )
                    Spacer(modifier = Modifier.height(16.dp))
                }
            }
        }
    }
}

package com.example.apptest.feature_train.presentation.trainings

import com.example.apptest.feature_train.domain.model.Training
import com.example.apptest.feature_train.domain.util.OrderType
import com.example.apptest.feature_train.domain.util.TrainingOrder

data class TrainingsState(
    // list of training items
    val trainings: List<Training> = emptyList(),
    // train list order
    val trainingOrder: TrainingOrder = TrainingOrder.Date(OrderType.Descending),
    val isOrderSectionVisible: Boolean = false
)

package com.example.apptest.feature_train.presentation.trainings

import androidx.compose.runtime.State
import androidx.compose.runtime.mutableStateOf
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.apptest.feature_train.domain.model.Training
import com.example.apptest.feature_train.domain.use_case.training_use_case.TrainingUseCases
import com.example.apptest.feature_train.domain.util.OrderType
import com.example.apptest.feature_train.domain.util.TrainingOrder
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.Job
import kotlinx.coroutines.flow.launchIn
import kotlinx.coroutines.flow.onEach
import kotlinx.coroutines.launch
import javax.inject.Inject


// used to inject a VM in a specific screen component
@HiltViewModel
class TrainingsViewModel @Inject constructor(
    private val trainingsUseCases: TrainingUseCases
    ): ViewModel(){

    private var recentlyDeletedTraining: Training? = null
    private var getTrainingsJob: Job? = null

    // state of this screen
    private val _state = mutableStateOf(TrainingsState())
    val state: State<TrainingsState> = _state

    init {
        getTrainings(TrainingOrder.Date(OrderType.Descending))
    }

    fun onEvent(event: TrainingsEvent){
        when(event){
            is TrainingsEvent.Order -> {
                // ::class is used to compare not equality of links, but of class types,
                // since trainorder is a class, not object like ordertype
                if (state.value.trainingOrder::class == event.trainingOrder::class &&
                    state.value.trainingOrder.orderType == event.trainingOrder.orderType)
                {
                    return
                }
                getTrainings(event.trainingOrder)
            }
            is TrainingsEvent.DeleteTraining -> {
                viewModelScope.launch {
                    trainingsUseCases.deleteTraining(event.training)
                    recentlyDeletedTraining = event.training
                }
            }
            is TrainingsEvent.RestoreTraining -> {
                viewModelScope.launch {
                    trainingsUseCases.addTraining(recentlyDeletedTraining ?: return@launch)
                    recentlyDeletedTraining = null
                }
            }
            // just hides and reveals order bttn
            is TrainingsEvent.ToggleOrderSection -> {
                _state.value = state.value.copy(
                    isOrderSectionVisible = !state.value.isOrderSectionVisible
                )
            }
        }
    }

    private fun getTrainings(trainingOrder: TrainingOrder){
        // if already trying to retrieve trainings from Dao, cancel attempt
        getTrainingsJob?.cancel()
        getTrainingsJob = trainingsUseCases.getAllTrainings(trainingOrder)
            .onEach {trainings ->
                _state.value = state.value.copy(
                    trainings = trainings,
                    trainingOrder = trainingOrder
                    // no selection of ordersection is specified, cause we wish to keep it consistent
                )
            }.launchIn(viewModelScope)
    }
}

package com.example.apptest.feature_train.presentation.util

sealed class Screen (
    val route: String
){
    object TrainingsScreen: Screen("trainings_screen")
    object AddEditTrainingScreen: Screen ("add_edit_training_screen")
}

package com.example.apptest

import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.animation.ExperimentalAnimationApi
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Surface
import androidx.navigation.NavType
import androidx.navigation.compose.NavHost
import androidx.navigation.compose.composable
import androidx.navigation.compose.rememberNavController
import androidx.navigation.navArgument
import com.example.apptest.feature_train.presentation.add_edit_training.AddEditTrainingsScreen
import com.example.apptest.feature_train.presentation.trainings.TrainingsScreen
import com.example.apptest.feature_train.presentation.util.Screen
import com.example.apptest.ui.theme.AppTestTheme
import dagger.hilt.android.AndroidEntryPoint

@AndroidEntryPoint
class MainActivity : ComponentActivity() {
    @OptIn(ExperimentalAnimationApi::class)
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            AppTestTheme {
                Surface(
                    color = MaterialTheme.colorScheme.background
                ) {
                    val navController = rememberNavController()
                    NavHost(
                        navController = navController,
                        startDestination = Screen.TrainingsScreen.route
                    ) {
                        composable(route = Screen.TrainingsScreen.route) {
                            TrainingsScreen(navController = navController)
                        }
                        composable(
                            route = Screen.AddEditTrainingScreen.route +
                                    "?trainingId={trainingId}",
                            arguments = listOf(
                                navArgument(
                                    name = "trainingId"
                                ) {
                                    type = NavType.IntType
                                    defaultValue = -1
                                }
                            )
                        ) {
                            AddEditTrainingsScreen(
                                navController = navController
                            )
                        }
                    }
                }
            }
        }
    }
}

!!!!!
THE ADD EDIT TRAINING PART
package com.example.apptest.feature_train.presentation.add_edit_training

data class AddEditCurrentTrainingState(
    val title: String = "",
    val date: Long = 0L,
    val failure: Boolean = false,
    val weights: String? = null,
    val trainingId: Int? = null,
    val isTitleHintVisible: Boolean = true,
    val isWeightHintVisible: Boolean = true
)
package com.example.apptest.feature_train.presentation.add_edit_training

import androidx.compose.ui.focus.FocusState

sealed class AddEditTrainingsEvent {
    data class EnteredTitle(val value: String) : AddEditTrainingsEvent()
    data class ChangeTitleFocus(val focusState: FocusState) : AddEditTrainingsEvent()
    data class EnteredWeight(val value: String) : AddEditTrainingsEvent()
    data class ChangeWeightFocus(val focusState: FocusState) : AddEditTrainingsEvent()
    data class ChangeFailureState(val value: Boolean) : AddEditTrainingsEvent()
    object SaveTraining : AddEditTrainingsEvent()
}

package com.example.apptest.feature_train.presentation.add_edit_training

import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.PaddingValues
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxHeight
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Save
import androidx.compose.material.icons.materialIcon
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.FloatingActionButton
import androidx.compose.material3.Icon
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Scaffold
import androidx.compose.material3.SnackbarHostState
import androidx.compose.material3.Text
import androidx.compose.material3.rememberStandardBottomSheetState
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.navigation.NavController
import com.example.apptest.R
import com.example.apptest.feature_train.presentation.add_edit_training.components.TransparentHintTextField
import kotlinx.coroutines.flow.collectLatest

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun AddEditTrainingsScreen(
    navController: NavController,
    viewModel: AddEditTrainingsViewModel = hiltViewModel()
) {
    val titleState = viewModel.trainingState.value
//    val dateState = viewModel.trainingState.value
    val weightsState = viewModel.trainingState.value
    val scaffoldState = remember { SnackbarHostState() }

    val scope = rememberCoroutineScope()

    LaunchedEffect(key1 = true) {
        viewModel.eventFlow.collectLatest { event ->
            when (event) {
                is AddEditTrainingsViewModel.UiEvent.ShowSnackbar -> {
                    scaffoldState.showSnackbar(
                        message = event.message
                    )
                }

                is AddEditTrainingsViewModel.UiEvent.SaveTraining -> {
                    navController.navigateUp()
                }
            }
        }
    }

    Scaffold(
        floatingActionButton = {
            FloatingActionButton(
                onClick = {
                    viewModel.onEvent(AddEditTrainingsEvent.SaveTraining)
                },
                containerColor = MaterialTheme.colorScheme.primary
            ) {
                Icon(
                    imageVector = Icons.Default.Save,
                    contentDescription = "Save note"
                )
            }
        }
    ) { padding ->
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp)
        )
        //
        //// TITLE
        //
        {
            TransparentHintTextField(
                text = titleState.title,
                hint = "Enter title...",
                isHintVisible = titleState.isTitleHintVisible,
                onValueChange = {
                    viewModel.onEvent(AddEditTrainingsEvent.EnteredTitle(it))
                },
                onFocusChange = {
                    viewModel.onEvent(AddEditTrainingsEvent.ChangeTitleFocus(it))
                },
                textStyle = MaterialTheme.typography.headlineSmall,
                singleLine = true
            )
            //
            //// no ne to handle changes in x   DATE

            //
            //// WEIGHTS
            //
            Spacer(modifier = Modifier.height(16.dp))
            TransparentHintTextField(
                text = weightsState.weights ?: "",
                hint = "Enter weights...",
                isHintVisible = weightsState.isWeightHintVisible,
                onValueChange = {
                    viewModel.onEvent(AddEditTrainingsEvent.EnteredWeight(it))
                },
                onFocusChange = {
                    viewModel.onEvent(AddEditTrainingsEvent.ChangeWeightFocus(it))
                },
                textStyle = MaterialTheme.typography.bodyMedium,
                singleLine = true
            )
            // Additional UI elements for failure state can be added here
        }
    }
}

package com.example.apptest.feature_train.presentation.add_edit_training

import androidx.compose.runtime.State
import androidx.compose.runtime.mutableStateOf
import androidx.lifecycle.SavedStateHandle
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.apptest.feature_train.domain.model.InvalidTrainingException
import com.example.apptest.feature_train.domain.model.Training
import com.example.apptest.feature_train.domain.use_case.training_use_case.TrainingUseCases
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableSharedFlow
import kotlinx.coroutines.flow.asSharedFlow
import kotlinx.coroutines.launch
import javax.inject.Inject

@HiltViewModel
class AddEditTrainingsViewModel @Inject constructor(
    private val trainingUseCases: TrainingUseCases,
    savedStateHandle: SavedStateHandle
) : ViewModel() {

    private val _trainingState = mutableStateOf(AddEditCurrentTrainingState())
    val trainingState: State<AddEditCurrentTrainingState> = _trainingState

    // for coroutine communication, one time event
    private val _eventFlow = MutableSharedFlow<UiEvent>()
    val eventFlow = _eventFlow.asSharedFlow()

    init {
        savedStateHandle.get<Int>("trainingId")?.let { trainingId ->
            if (trainingId != -1) {
                viewModelScope.launch {
                    trainingUseCases.getTrainingById(trainingId)?.also { training ->
                        _trainingState.value = trainingState.value.copy(
                            title = training.title,
                            date = training.date,
                            failure = training.failure,
                            weights = training.weights.toString(),
                            trainingId = training.id,
                            isTitleHintVisible = false,
                            isWeightHintVisible = training.weights != null
                        )
                    }
                }
            } else {
                // Initialize for a new training
                _trainingState.value = AddEditCurrentTrainingState(
                    title = "",
                    date = System.currentTimeMillis(), // Or any default date logic
                    failure = false,
                    weights = null,
                    // ... other default values ...
                    isTitleHintVisible = true,
                    isWeightHintVisible = true
                )
            }
        }
    }

    // copy method is used to _recreate_ the private _state with new fields, not reassign them;
    // when new _state instance is created, Compose compares it with previous instance line by linde;
    // If changes found, it recomposes dependent composables
    fun onEvent(event: AddEditTrainingsEvent) {
        when (event) {
            is AddEditTrainingsEvent.EnteredTitle -> {
                _trainingState.value = trainingState.value.copy(
                    title = event.value,
                    isTitleHintVisible = event.value.isBlank()
                )
            }
            is AddEditTrainingsEvent.ChangeTitleFocus -> {
                _trainingState.value = trainingState.value.copy(
                    isTitleHintVisible = !event.focusState.isFocused && trainingState.value.title.isBlank()
                )
            }

            is AddEditTrainingsEvent.EnteredWeight -> {
                _trainingState.value = trainingState.value.copy(
                    weights = event.value,
                    isWeightHintVisible = event.value.isBlank()
                )
            }
            is AddEditTrainingsEvent.ChangeWeightFocus -> {
                _trainingState.value = trainingState.value.copy(
                    isWeightHintVisible = !event.focusState.isFocused && trainingState.value.weights.isNullOrBlank()
                )
            }
            is AddEditTrainingsEvent.ChangeFailureState -> {
                _trainingState.value = trainingState.value.copy(
                    failure = event.value
                )
            }
            is AddEditTrainingsEvent.SaveTraining -> {
                viewModelScope.launch {
                    try {
                        trainingUseCases.addTraining(
                            Training(
                                title = trainingState.value.title,
                                date = trainingState.value.date,
                                failure = trainingState.value.failure,
                                weights = trainingState.value.weights?.toIntOrNull(),
                                id = trainingState.value.trainingId ?: 0
                            )
                        )
                        _eventFlow.emit(UiEvent.SaveTraining)
                    } catch (e: InvalidTrainingException) {
                        _eventFlow.emit(
                            UiEvent.ShowSnackbar(
                                message = e.message ?: "Couldn't save training"
                            )
                        )
                    }
                }
            }
        }
    }

    sealed class UiEvent {
        data class ShowSnackbar(val message: String) : UiEvent()
        object SaveTraining : UiEvent()
    }
}



!!!!!!!!!
TASK:
I have to create exercise feature, functionally the analogue to the trainings. I will have a list of exercises
and a screen to edit/create one. At this moment I wish you to implement the following files as analgue to
the trainings code:
1. All exercise use cases, except update (not used)
2. GetAllExercises file
3. ExercisesRepositoryImpl file

Here is what I already have from files:

@Dao
interface ExerciseDao {
    @Query("SELECT * FROM Exercise")
    fun getAllExercises(): Flow<List<Exercise>>

    @Query("SELECT * FROM Exercise WHERE id = :exerciseId")
    suspend fun getExerciseById(exerciseId: Int): Exercise? // Suspend function is correct here

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun addExercise(exercise: Exercise) // Suspend function is correct here

    @Delete
    suspend fun deleteExercise(exercise: Exercise) // Suspend function is correct here
}

import androidx.room.Database
import androidx.room.RoomDatabase
import com.example.apptest.feature_train.domain.model.Exercise
import com.example.apptest.feature_train.domain.model.Training

@Database(
    entities = [Training::class, Exercise::class],
    version = 1, // Simplified version
)
abstract class TrainDatabase : RoomDatabase() {
    abstract val trainingDao: TrainingDao

    companion object {
        const val DATABASE_NAME = "trainings_db"
    }
}

package com.example.apptest.feature_train.domain.repository

import com.example.apptest.feature_train.domain.model.Exercise
import kotlinx.coroutines.flow.Flow

interface ExerciseRepository {

    fun getAllExercises(): Flow<List<Exercise>>

    suspend fun getExerciseById(exerciseId: Int): Exercise?

    suspend fun addExercise(exercise: Exercise)

    suspend fun deleteExercise(exercise: Exercise)
}

package com.example.apptest.feature_train.domain.util

sealed class ExerciseOrder (val orderType: OrderType) {
    class Title(orderType: OrderType): ExerciseOrder(orderType)
    class Date(orderType: OrderType): ExerciseOrder(orderType)

    fun copy(orderType: OrderType): ExerciseOrder{
        return when (this){
            is Title -> Title(orderType)
            is Date -> Date(orderType)
        }
    }
}

package com.example.apptest.feature_train.domain.util

sealed class OrderType {
    object Ascending: OrderType()
    object Descending: OrderType()
}

