Context:
Here is my  whole codebase.
At all we would have three entities:
a. Training - contains a title,date, failure checkbox, weights used and _important_ A list of used TrainingExercises!
b. Exercise - contains a name, description and ExerciseType parameter which specifies whether this exercises is static (time) or active (repetitions count);
c. TrainingExercise - it is an Exercise, but with specified reps or duration (depends on the parent exercise template type)

I wish see this as a result:
A. Training Screen:
1. The trainings screen contains all trainings, but without details of each training;
2. We can create a training or edit it by clicking on specific training or pressing add button on the trainings screen, this redirects to AddEditTraining screen;
3. This screen has a button "exercises" that redirects to exercises screen;
B. AddEditTraining screen:
3 When a specific training is opened (or created) user can press button "used exercises" (under it is a list of TrainingExercises used in training) and see a composable list of available exercises templates to be filled later;
3.1 that exercises composable drop list contains just the fillable objects of exercises (the exercises templates are managed from Exercises screen), for example exercise pull-up, push-up, planc etc
3.2 When any of exercises in that list is clicked, the windows appears that suggests to specify the amount of reps / duration for that trainingExercise;
3.3 User fills it up, the popup windows hides, user is back to the drop list of exercises templates, where he could add other exercises to the managed training;
4. When user leaves the the list of exercises templates, he can see the list of TrainingExercises added (or fetched if training is edited not created)

Tips:
- Training exercises list is unique for any training, because it contains specific trainingexercises as well as their duration/reps values;
- Create a trainingExercises package as analogue to trainings and exercises
- Create trainingExercises use cases
- keep composables atomic, do not overthink to add exccess functionality if it can be putted to a separate file;

Pipeline:
- Please review the current pipeline, change files to fulfill requirement, create new files as requested.
- provide files in a separate code blocks with names of files for better copying;
- if file doesn't need to be changed, then omit it and go on


current CODEBASE to adjust:


package com.example.apptest.di

import android.app.Application
import androidx.room.Room
import androidx.room.migration.Migration
import androidx.sqlite.db.SupportSQLiteDatabase
import com.example.apptest.feature_train.data.data_source.TrainDatabase
import com.example.apptest.feature_train.data.repository.ExerciseRepositoryImpl
import com.example.apptest.feature_train.data.repository.TrainingRepositoryImpl
import com.example.apptest.feature_train.domain.repository.ExerciseRepository
import com.example.apptest.feature_train.domain.repository.TrainingRepository
import com.example.apptest.feature_train.domain.use_case.exercise_use_case.AddExercise
import com.example.apptest.feature_train.domain.use_case.exercise_use_case.DeleteExercise
import com.example.apptest.feature_train.domain.use_case.exercise_use_case.ExerciseUseCases
import com.example.apptest.feature_train.domain.use_case.exercise_use_case.GetAllExercises
import com.example.apptest.feature_train.domain.use_case.exercise_use_case.GetExerciseById
import com.example.apptest.feature_train.domain.use_case.training_use_case.AddTraining
import com.example.apptest.feature_train.domain.use_case.training_use_case.DeleteTraining
import com.example.apptest.feature_train.domain.use_case.training_use_case.GetAllTrainings
import com.example.apptest.feature_train.domain.use_case.training_use_case.GetTrainingById
import com.example.apptest.feature_train.domain.use_case.training_use_case.TrainingUseCases
import com.example.apptest.feature_train.domain.use_case.training_use_case.UpdateTraining
import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.components.SingletonComponent
import javax.inject.Singleton


@Module
@InstallIn(SingletonComponent::class)
object AppModule {

//    private val MIGRATION_1_2 = object : Migration(1, 2) {
//        override fun migrate(db: SupportSQLiteDatabase) {
//            // Add the new column to the Exercise table.
//            // Since we are using a TypeConverter, we store the ExerciseType as TEXT.
//            db.execSQL("ALTER TABLE Exercise ADD COLUMN exerciseType TEXT")
//
//            // Set a default value for the new column (optional).
//            // This is useful if you don't want to delete existing data.
//            // You can set a default ExerciseType, like 'Reps,0' or 'Duration,0'.
//            db.execSQL("UPDATE Exercise SET exerciseType = 'Reps,0'")
//        }
//    }

    @Provides
    @Singleton
    fun provideTrainDatabase(app: Application): TrainDatabase {
        return Room.databaseBuilder(
            app,
            TrainDatabase::class.java,
            TrainDatabase.DATABASE_NAME
        )
//            .addMigrations(MIGRATION_1_2) // Add the migration here
            .build()
    }

    @Provides
    @Singleton
    fun provideTrainingRepository(db: TrainDatabase): TrainingRepository {
        // when database created an instance of trainingDao is created as well and consumed here
        return TrainingRepositoryImpl(db.trainingDao)
//        return FakeTrainingRepository()
    }

    @Provides
    @Singleton
    fun provideTrainingUseCases(repository: TrainingRepository) : TrainingUseCases {
        return TrainingUseCases(
            addTraining = AddTraining(repository),
            deleteTraining = DeleteTraining(repository),
            getAllTrainings = GetAllTrainings(repository),
            getTrainingById = GetTrainingById(repository),
            updateTraining = UpdateTraining(repository)
        )
    }


    @Provides
    @Singleton
    fun provideExerciseRepository(db: TrainDatabase): ExerciseRepository {
        // when database created an instance of exerciseDao is created as well and consumed here
        return ExerciseRepositoryImpl(db.exerciseDao)
    }


    @Provides
    @Singleton
    fun provideExerciseUseCases(repository: ExerciseRepository) : ExerciseUseCases {
        return ExerciseUseCases(
            addExercise = AddExercise(repository),
            deleteExercise = DeleteExercise(repository),
            getAllExercises = GetAllExercises(repository),
            getExerciseById = GetExerciseById(repository)
        )
    }
}

package com.example.apptest.feature_train.data.data_source

import androidx.room.Dao
import androidx.room.Delete
import androidx.room.Insert
import androidx.room.OnConflictStrategy
import androidx.room.Query
import com.example.apptest.feature_train.domain.model.Exercise
import kotlinx.coroutines.flow.Flow

@Dao
interface ExerciseDao {
    @Query("SELECT * FROM Exercise")
    fun getAllExercises(): Flow<List<Exercise>>

    @Query("SELECT * FROM Exercise WHERE id = :exerciseId")
    suspend fun getExerciseById(exerciseId: Int): Exercise? // Suspend function is correct here

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun addExercise(exercise: Exercise) // Suspend function is correct here

    @Delete
    suspend fun deleteExercise(exercise: Exercise) // Suspend function is correct here
}
package com.example.apptest.feature_train.data.data_source

import androidx.room.TypeConverter
import com.example.apptest.feature_train.domain.model.ExerciseType

class ExerciseTypeConverter {

    @TypeConverter
    fun fromExerciseType(exerciseType: ExerciseType): String {
        return when (exerciseType) {
            is ExerciseType.Reps -> "Reps,${exerciseType.reps}"
            is ExerciseType.Duration -> "Duration,${exerciseType.time}"
        }
    }

    @TypeConverter
    fun toExerciseType(value: String): ExerciseType {
        val parts = value.split(",")
        return when (parts[0]) {
            "Reps" -> ExerciseType.Reps(parts[1].toInt())
            "Duration" -> ExerciseType.Duration(parts[1].toInt())
            else -> throw IllegalArgumentException("Unknown ExerciseType")
        }
    }
}package com.example.apptest.feature_train.data.data_source

import androidx.room.Database
import androidx.room.RoomDatabase
import androidx.room.TypeConverters
import com.example.apptest.feature_train.domain.model.Exercise
import com.example.apptest.feature_train.domain.model.Training

@Database(
    entities = [Training::class, Exercise::class],
    version = 1, // Don't forget to update version
    exportSchema = false
)
@TypeConverters(ExerciseTypeConverter::class)
abstract class TrainDatabase : RoomDatabase() {
    abstract val trainingDao: TrainingDao
    abstract val exerciseDao: ExerciseDao

    companion object {
        const val DATABASE_NAME = "trainings_db"
    }
}package com.example.apptest.feature_train.data.data_source

import androidx.room.Dao
import androidx.room.Delete
import androidx.room.Insert
import androidx.room.OnConflictStrategy
import androidx.room.Query
import androidx.room.Update
import com.example.apptest.feature_train.domain.model.Training
import kotlinx.coroutines.flow.Flow


@Dao
interface TrainingDao {
    @Query("SELECT * FROM Training")
    fun getAllTrainings(): Flow<List<Training>>

    @Query("SELECT * FROM Training WHERE id = :trainingId")
    suspend fun getTrainingById(trainingId: Int): Training? // Suspend function is correct here

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun addTraining(training: Training) // Suspend function is correct here

    @Update
    suspend fun updateTraining(training: Training) // Suspend function is correct here

    @Delete
    suspend fun deleteTraining(training: Training) // Suspend function is correct here
}package com.example.apptest.feature_train.data.repository

import com.example.apptest.feature_train.data.data_source.ExerciseDao
import com.example.apptest.feature_train.domain.model.Exercise
import com.example.apptest.feature_train.domain.repository.ExerciseRepository
import kotlinx.coroutines.flow.Flow

class ExerciseRepositoryImpl(
    private val dao: ExerciseDao
) : ExerciseRepository {

    override fun getAllExercises(): Flow<List<Exercise>> {
        return dao.getAllExercises()
    }

    override suspend fun getExerciseById(exerciseId: Int): Exercise? {
        return dao.getExerciseById(exerciseId)
    }

    override suspend fun addExercise(exercise: Exercise) {
        dao.addExercise(exercise)
    }

    override suspend fun deleteExercise(exercise: Exercise) {
        dao.deleteExercise(exercise)
    }
}package com.example.apptest.feature_train.data.repository

import com.example.apptest.feature_train.data.data_source.TrainingDao
import com.example.apptest.feature_train.domain.model.Training
import com.example.apptest.feature_train.domain.repository.TrainingRepository
import kotlinx.coroutines.flow.Flow

class TrainingRepositoryImpl(
    private val dao: TrainingDao
) : TrainingRepository {

    override fun getAllTrainings(): Flow<List<Training>> {
        return dao.getAllTrainings()
    }

    override suspend fun getTrainingById(trainingId: Int): Training? {
        return dao.getTrainingById(trainingId)
    }

    override suspend fun addTraining(training: Training) {
        dao.addTraining(training)
    }

    override suspend fun updateTraining(training: Training) {
        dao.updateTraining(training)
    }

    override suspend fun deleteTraining(training: Training) {
        dao.deleteTraining(training)
    }
}
package com.example.apptest.feature_train.domain.model

package com.example.apptest.feature_train.domain.model

import androidx.room.Entity
import androidx.room.PrimaryKey

@Entity
data class Exercise(
    val name: String,
    val description: String? = null,
    val exerciseType: ExerciseType,
    @PrimaryKey(autoGenerate = true) val id: Int? = null
)

class InvalidExerciseException(message: String) : Exception(message)

package com.example.apptest.feature_train.domain.model

sealed class ExerciseType {
    data class Reps(val reps: Int) : ExerciseType()
    data class Duration(val time: Int) : ExerciseType()
}
package com.example.apptest.feature_train.domain.model

import androidx.room.Entity
import androidx.room.PrimaryKey

@Entity
data class Training(
    val title: String,
    val date: Long,
    val failure: Boolean = false,
    val weights: Long? = null,
    @PrimaryKey(autoGenerate = true) val id: Int = 0 // Auto-generate ID
)

class InvalidTrainingException(message: String) : Exception(message)

package com.example.apptest.feature_train.domain.model

import androidx.room.Entity
import androidx.room.ForeignKey

@Entity(
    primaryKeys = ["trainingId", "exerciseId"],
    foreignKeys = [
        ForeignKey(
            entity = Training::class,
            parentColumns = ["id"],
            childColumns = ["trainingId"],
            onDelete = ForeignKey.CASCADE
        ),
        ForeignKey(
            entity = Exercise::class,
            parentColumns = ["id"],
            childColumns = ["exerciseId"],
            onDelete = ForeignKey.CASCADE
        )
    ]
)
data class TrainingExercise(
    val trainingId: Int,
    val exerciseId: Int,
    val reps: Int?, // Nullable for duration-based exercises
    val duration: Int?, // Nullable for rep-based exercises
    val failure: Boolean = false
)

package com.example.apptest.feature_train.domain.repository

import com.example.apptest.feature_train.domain.model.Exercise
import kotlinx.coroutines.flow.Flow

interface ExerciseRepository {

    fun getAllExercises(): Flow<List<Exercise>>

    suspend fun getExerciseById(exerciseId: Int): Exercise?

    suspend fun addExercise(exercise: Exercise)

    suspend fun deleteExercise(exercise: Exercise)
}

package com.example.apptest.feature_train.domain.repository

import com.example.apptest.feature_train.domain.model.Training
import kotlinx.coroutines.flow.Flow

interface TrainingRepository {

    fun getAllTrainings(): Flow<List<Training>>

    suspend fun getTrainingById(trainingId: Int): Training?

    suspend fun addTraining(training: Training)

    suspend fun updateTraining(training: Training)

    suspend fun deleteTraining(training: Training)
}

package com.example.apptest.feature_train.domain.use_case.exercise_use_case

import com.example.apptest.feature_train.domain.model.Exercise
import com.example.apptest.feature_train.domain.model.ExerciseType
import com.example.apptest.feature_train.domain.model.InvalidExerciseException
import com.example.apptest.feature_train.domain.repository.ExerciseRepository

class AddExercise(private val repository: ExerciseRepository) {
    @Throws(InvalidExerciseException::class)
    suspend operator fun invoke(exercise: Exercise) {
        if (exercise.name.isBlank()) {
            throw InvalidExerciseException("Exercise name must not be empty.")
        }

        repository.addExercise(exercise)
    }
}
package com.example.apptest.feature_train.domain.use_case.exercise_use_case

import com.example.apptest.feature_train.domain.model.Exercise
import com.example.apptest.feature_train.domain.repository.ExerciseRepository

class DeleteExercise(private val repository: ExerciseRepository) {
    suspend operator fun invoke(exercise: Exercise) {
        repository.deleteExercise(exercise)
    }
}package com.example.apptest.feature_train.domain.use_case.exercise_use_case

 import com.example.apptest.feature_train.domain.use_case.training_use_case.AddTraining
 import com.example.apptest.feature_train.domain.use_case.training_use_case.DeleteTraining
 import com.example.apptest.feature_train.domain.use_case.training_use_case.GetAllTrainings
 import com.example.apptest.feature_train.domain.use_case.training_use_case.GetTrainingById

 data class ExerciseUseCases(
     val addExercise: AddExercise,
     val deleteExercise: DeleteExercise,
     val getAllExercises: GetAllExercises,
     val getExerciseById: GetExerciseById
 )package com.example.apptest.feature_train.domain.use_case.exercise_use_case

  import com.example.apptest.feature_train.domain.model.Exercise
  import com.example.apptest.feature_train.domain.model.ExerciseType

  import com.example.apptest.feature_train.domain.repository.ExerciseRepository
  import com.example.apptest.feature_train.domain.util.ExerciseOrder
  import com.example.apptest.feature_train.domain.util.OrderType
  import kotlinx.coroutines.flow.Flow
  import kotlinx.coroutines.flow.map

  class GetAllExercises(private val repository: ExerciseRepository) {
      operator fun invoke(
          exerciseOrder: ExerciseOrder = ExerciseOrder.Type(OrderType.Descending) // Default changed to Type
      ): Flow<List<Exercise>> {
          return repository.getAllExercises().map { exercises ->
              when (exerciseOrder.orderType) {
                  is OrderType.Ascending -> {
                      when (exerciseOrder) {
                          is ExerciseOrder.Title -> exercises.sortedBy { it.name.lowercase() }
                          is ExerciseOrder.Type -> exercises.sortedWith(compareBy {
                              when (it.exerciseType) { // Sorting logic based on ExerciseType
                                  is ExerciseType.Reps -> 0
                                  is ExerciseType.Duration -> 1
                              }
                          })
                      }
                  }

                  is OrderType.Descending -> {
                      when (exerciseOrder) {
                          is ExerciseOrder.Title -> exercises.sortedByDescending { it.name.lowercase() }
                          is ExerciseOrder.Type -> exercises.sortedWith(compareByDescending {
                              when (it.exerciseType) {
                                  is ExerciseType.Reps -> 0
                                  is ExerciseType.Duration -> 1
                              }
                          })
                      }
                  }
              }
          }
      }
  }package com.example.apptest.feature_train.domain.use_case.exercise_use_case

   import com.example.apptest.feature_train.domain.model.Exercise
   import com.example.apptest.feature_train.domain.repository.ExerciseRepository

   class GetExerciseById(private val repository: ExerciseRepository) {
       suspend operator fun invoke(exerciseId: Int): Exercise? {
           return repository.getExerciseById(exerciseId)
       }
   }package com.example.apptest.feature_train.domain.use_case.training_use_case

    import com.example.apptest.feature_train.domain.model.InvalidTrainingException
    import com.example.apptest.feature_train.domain.model.Training
    import com.example.apptest.feature_train.domain.repository.TrainingRepository

    class AddTraining(private val repository: TrainingRepository) {
        suspend operator fun invoke(training: Training) {
            // Check if title (name) is specified
            if (training.title.isBlank()) {
                throw InvalidTrainingException("Training name must not be empty.")
            }

            // Add the training to the repository
            repository.addTraining(training)
        }
    }package com.example.apptest.feature_train.domain.use_case.training_use_case

     import com.example.apptest.feature_train.domain.model.Training
     import com.example.apptest.feature_train.domain.repository.TrainingRepository

     class DeleteTraining(private val repository: TrainingRepository) {
         suspend operator fun invoke(training: Training) {
             repository.deleteTraining(training)
         }
     }
package com.example.apptest.feature_train.domain.use_case.training_use_case

import com.example.apptest.feature_train.domain.model.Training
import com.example.apptest.feature_train.domain.repository.TrainingRepository
import com.example.apptest.feature_train.domain.util.OrderType
import com.example.apptest.feature_train.domain.util.TrainingOrder
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map

class GetAllTrainings(private val repository: TrainingRepository) {
    operator fun invoke(
        //date by default
        exerciseOrder: TrainingOrder = TrainingOrder.Date(OrderType.Descending)
    ): Flow<List<Training>> {
        return repository.getAllTrainings().map {trainings ->
            when(exerciseOrder.orderType) {
                is OrderType.Ascending -> {
                    when(exerciseOrder) {
                        is TrainingOrder.Title -> trainings.sortedBy { it.title.lowercase() }
                        is TrainingOrder.Date -> trainings.sortedBy { it.date }
                    }
                }
                is OrderType.Descending -> {
                    when(exerciseOrder) {
                        is TrainingOrder.Title -> trainings.sortedByDescending { it.title.lowercase() }
                        is TrainingOrder.Date -> trainings.sortedByDescending { it.date }
                    }
                }
            }
        }
    }
}
package com.example.apptest.feature_train.domain.use_case.training_use_case

import com.example.apptest.feature_train.domain.model.Training
import com.example.apptest.feature_train.domain.repository.TrainingRepository

class GetTrainingById(private val repository: TrainingRepository) {
    suspend operator fun invoke(trainingId: Int): Training? {
        return repository.getTrainingById(trainingId)
    }
}
package com.example.apptest.feature_train.domain.use_case.training_use_case

data class TrainingUseCases(
    val addTraining: AddTraining,
    val deleteTraining: DeleteTraining,
    val getAllTrainings: GetAllTrainings,
    val getTrainingById: GetTrainingById,
    val updateTraining: UpdateTraining
)
package com.example.apptest.feature_train.domain.use_case.training_use_case

import com.example.apptest.feature_train.domain.model.Training
import com.example.apptest.feature_train.domain.repository.TrainingRepository

class UpdateTraining(private val repository: TrainingRepository) {
    suspend operator fun invoke(training: Training) {
        repository.updateTraining(training)
    }
}package com.example.apptest.feature_train.domain.use_case.trainingExercise_use_case

 import com.example.apptest.feature_train.domain.model.TrainingExercise
 import com.example.apptest.feature_train.domain.repository.TrainingExerciseRepository

 class AddTrainingExercise(
     private val repository: TrainingExerciseRepository
 ) {
     suspend operator fun invoke(trainingExercise: TrainingExercise) {
         repository.insertTrainingExercise(trainingExercise)
     }
 }package com.example.apptest.feature_train.domain.use_case.trainingExercise_use_case

  import com.example.apptest.feature_train.domain.model.TrainingExercise
  import com.example.apptest.feature_train.domain.repository.TrainingExerciseRepository

  class DeleteTrainingExercise(
      private val repository: TrainingExerciseRepository
  ) {
      suspend operator fun invoke(trainingExercise: TrainingExercise) {
          repository.deleteTrainingExercise(trainingExercise)
      }
  }package com.example.apptest.feature_train.domain.use_case.trainingExercise_use_case

   import com.example.apptest.feature_train.domain.model.TrainingExercise
   import com.example.apptest.feature_train.domain.repository.TrainingExerciseRepository
   import kotlinx.coroutines.flow.Flow

   class GetExercisesForTraining(
       private val repository: TrainingExerciseRepository
   ) {
       operator fun invoke(trainingId: Int): Flow<List<TrainingExercise>> {
           return repository.getExercisesForTraining(trainingId)
       }
   }package com.example.apptest.feature_train.domain.use_case.trainingExercise_use_case

    import com.example.apptest.feature_train.domain.use_case.trainingExercise_use_case.AddTrainingExercise
    import com.example.apptest.feature_train.domain.use_case.trainingExercise_use_case.DeleteTrainingExercise
    import com.example.apptest.feature_train.domain.use_case.trainingExercise_use_case.GetExercisesForTraining

    data class TrainingExerciseUseCases(
        val addTrainingExercise: AddTrainingExercise,
        val deleteTrainingExercise: DeleteTrainingExercise,
        val getExercisesForTraining: GetExercisesForTraining
    )package com.example.apptest.feature_train.domain.util

     sealed class TrainingOrder (val orderType: OrderType) {
         class Title(orderType: OrderType): TrainingOrder(orderType)
         class Date(orderType: OrderType): TrainingOrder(orderType)

         fun copy(orderType: OrderType): TrainingOrder{
             return when (this){
                 is Title -> Title(orderType)
                 is Date -> Date(orderType)
             }
         }
     }package com.example.apptest.feature_train.domain.util

     sealed class OrderType {
         object Ascending: OrderType()
         object Descending: OrderType()
     }package com.example.apptest.feature_train.domain.util

     import com.example.apptest.feature_train.domain.model.ExerciseType

     sealed class ExerciseOrder(val orderType: OrderType) {
         class Title(orderType: OrderType) : ExerciseOrder(orderType)
         class Type(orderType: OrderType) : ExerciseOrder(orderType) // Changed Date to Type

         fun copy(orderType: OrderType): ExerciseOrder {
             return when (this) {
                 is Title -> Title(orderType)
                 is Type -> Type(orderType) // Also update here
             }
         }
     }package com.example.apptest.feature_train.presentation.add_edit_exercise

      import com.example.apptest.feature_train.domain.model.ExerciseType

      data class AddEditCurrentExerciseState(
          val title: String = "",
          val description: String = "",
          val exerciseType: ExerciseType = ExerciseType.Reps,
          val exerciseId: Int? = null,
          val isTitleHintVisible: Boolean = true,
          val isDescriptionHintVisible: Boolean = true
      )package com.example.apptest.feature_train.presentation.add_edit_exercise

       import androidx.compose.ui.focus.FocusState
       import com.example.apptest.feature_train.domain.model.ExerciseType

       sealed class AddEditExercisesEvent {
           data class EnteredTitle(val value: String) : AddEditExercisesEvent()
           data class ChangeTitleFocus(val focusState: FocusState) : AddEditExercisesEvent()
           data class EnteredDescription(val value: String) : AddEditExercisesEvent()
           data class ChangeDescriptionFocus(val focusState: FocusState) : AddEditExercisesEvent()
           data class ChangeExerciseType(val exerciseType: ExerciseType) : AddEditExercisesEvent()
           object SaveExercise : AddEditExercisesEvent()
       }package com.example.apptest.feature_train.presentation.add_edit_exercise

        import androidx.compose.foundation.layout.*
        import androidx.compose.foundation.text.KeyboardOptions
        import androidx.compose.material3.*
        import androidx.compose.material.icons.Icons
        import androidx.compose.material.icons.filled.Save
        import androidx.compose.runtime.Composable
        import androidx.compose.runtime.LaunchedEffect
        import androidx.compose.runtime.remember
        import androidx.compose.runtime.*
        import androidx.compose.ui.Modifier
        import androidx.compose.ui.text.input.KeyboardType
        import androidx.compose.ui.unit.dp
        import androidx.hilt.navigation.compose.hiltViewModel
        import androidx.navigation.NavController
        import com.example.apptest.feature_train.domain.model.ExerciseType
        import com.example.apptest.feature_train.presentation.add_edit_training.components.TransparentHintTextField
        import kotlinx.coroutines.flow.collectLatest

        @OptIn(ExperimentalMaterial3Api::class)
        @Composable
        fun AddEditExercisesScreen(
            navController: NavController,
            viewModel: AddEditExercisesViewModel = hiltViewModel()
        ) {
            val titleState = viewModel.exerciseState.value
            val descriptionState = viewModel.exerciseState.value
            val exerciseTypeState = viewModel.exerciseState.value.exerciseType

            val scaffoldState = remember { SnackbarHostState() }

            LaunchedEffect(key1 = true) {
                viewModel.eventFlow.collectLatest { event ->
                    when(event) {
                        is AddEditExercisesViewModel.UiEvent.ShowSnackbar -> {
                            scaffoldState.showSnackbar(
                                message = event.message
                            )
                        }
                        is AddEditExercisesViewModel.UiEvent.SaveExercise -> {
                            navController.navigateUp()
                        }
                    }
                }
            }

            Scaffold(
                floatingActionButton = {
                    FloatingActionButton(
                        onClick = {
                            viewModel.onEvent(AddEditExercisesEvent.SaveExercise)
                        },
                        containerColor = MaterialTheme.colorScheme.primary
                    ) {
                        Icon(
                            imageVector = Icons.Default.Save,
                            contentDescription = "Save exercise"
                        )
                    }
                },
                snackbarHost = { SnackbarHost(scaffoldState) }
            ) { padding ->
                Column(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(16.dp)
                ) {
                    // Title
                    TransparentHintTextField(
                        text = titleState.title,
                        hint = "Enter title...",
                        isHintVisible = titleState.isTitleHintVisible,
                        onValueChange = {
                            viewModel.onEvent(AddEditExercisesEvent.EnteredTitle(it))
                        },
                        onFocusChange = {
                            viewModel.onEvent(AddEditExercisesEvent.ChangeTitleFocus(it))
                        },
                        textStyle = MaterialTheme.typography.headlineSmall,
                        singleLine = true
                    )
                    Spacer(modifier = Modifier.height(16.dp))

                    // Description
                    TransparentHintTextField(
                        text = descriptionState.description,
                        hint = "Enter description...",
                        isHintVisible = descriptionState.isDescriptionHintVisible,
                        onValueChange = {
                            viewModel.onEvent(AddEditExercisesEvent.EnteredDescription(it))
                        },
                        onFocusChange = {
                            viewModel.onEvent(AddEditExercisesEvent.ChangeDescriptionFocus(it))
                        },
                        textStyle = MaterialTheme.typography.bodyMedium,
                        singleLine = false,
                        modifier = Modifier.height(120.dp)
                    )
                    Spacer(modifier = Modifier.height(16.dp))

                    // Exercise Type Selection
                    ExerciseTypeSelector(
                        exerciseType = exerciseTypeState,
                        onTypeChange = {
                            viewModel.onEvent(AddEditExercisesEvent.ChangeExerciseType(it))
                        }
                    )
                }
            }
        }

        @Composable
        fun ExerciseTypeSelector(
            exerciseType: ExerciseType,
            onTypeChange: (ExerciseType) -> Unit
        ) {
            var selectedType by remember { mutableStateOf(exerciseType) }

            Column {
                Text("Exercise Type:", style = MaterialTheme.typography.bodyMedium)
                Spacer(modifier = Modifier.height(8.dp))

                Row {
                    RadioButton(
                        selected = selectedType is ExerciseType.Reps,
                        onClick = {
                            selectedType = ExerciseType.Reps
                            onTypeChange(selectedType)
                        },
                        colors = RadioButtonDefaults.colors(
                            selectedColor = MaterialTheme.colorScheme.primary,
                            unselectedColor = MaterialTheme.colorScheme.onBackground
                        )
                    )
                    Text("Reps")

                    Spacer(modifier = Modifier.width(16.dp))

                    RadioButton(
                        selected = selectedType is ExerciseType.Duration,
                        onClick = {
                            selectedType = ExerciseType.Duration
                            onTypeChange(selectedType)
                        },
                        colors = RadioButtonDefaults.colors(
                            selectedColor = MaterialTheme.colorScheme.primary,
                            unselectedColor = MaterialTheme.colorScheme.onBackground
                        )
                    )
                    Text("Duration")
                }

                Spacer(modifier = Modifier.height(8.dp))

        //        when (selectedType) {
        //            is ExerciseType.Reps -> {
        //                var reps by remember { mutableStateOf(if (exerciseType is ExerciseType.Reps) exerciseType.reps else 0) }
        //                TextField(
        //                    value = reps.toString(),
        //                    onValueChange = { newValue ->
        //                        reps = newValue.toIntOrNull() ?: 0
        //                        onTypeChange(ExerciseType.Reps(reps))
        //                    },
        //                    label = { Text("Reps") },
        //                    keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number)
        //                )
        //            }
        //            is ExerciseType.Duration -> {
        //                var duration by remember { mutableStateOf(if (exerciseType is ExerciseType.Duration) exerciseType.time else 0) }
        //                TextField(
        //                    value = duration.toString(),
        //                    onValueChange = { newValue ->
        //                        duration = newValue.toIntOrNull() ?: 0
        //                        onTypeChange(ExerciseType.Duration(duration))
        //                    },
        //                    label = { Text("Duration (seconds)") },
        //                    keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number)
        //                )
        //            }
        //        }
            }
        }package com.example.apptest.feature_train.presentation.add_edit_exercise

         import androidx.compose.runtime.State
         import androidx.compose.runtime.mutableStateOf
         import androidx.lifecycle.SavedStateHandle
         import androidx.lifecycle.ViewModel
         import androidx.lifecycle.viewModelScope
         import com.example.apptest.feature_train.domain.model.Exercise
         import com.example.apptest.feature_train.domain.model.ExerciseType
         import com.example.apptest.feature_train.domain.model.InvalidExerciseException
         import com.example.apptest.feature_train.domain.use_case.exercise_use_case.ExerciseUseCases
         import dagger.hilt.android.lifecycle.HiltViewModel
         import kotlinx.coroutines.flow.MutableSharedFlow
         import kotlinx.coroutines.flow.asSharedFlow
         import kotlinx.coroutines.launch
         import javax.inject.Inject

         @HiltViewModel
         class AddEditExercisesViewModel @Inject constructor(
             private val exerciseUseCases: ExerciseUseCases,
             savedStateHandle: SavedStateHandle
         ) : ViewModel() {

             private val _exerciseState = mutableStateOf(AddEditCurrentExerciseState())
             val exerciseState: State<AddEditCurrentExerciseState> = _exerciseState

             private val _eventFlow = MutableSharedFlow<UiEvent>()
             val eventFlow = _eventFlow.asSharedFlow()

             init {
                 savedStateHandle.get<Int>("exerciseId")?.let { exerciseId ->
                     if (exerciseId != -1) {
                         viewModelScope.launch {
                             exerciseUseCases.getExerciseById(exerciseId)?.also { exercise ->
                                 _exerciseState.value = exerciseState.value.copy(
                                     title = exercise.name,
                                     description = exercise.description ?: "",
                                     exerciseType = exercise.exerciseType,
                                     exerciseId = exercise.id,
                                     isTitleHintVisible = false,
                                     isDescriptionHintVisible = exercise.description.isNullOrBlank()
                                 )
                             }
                         }
                     } else {
                         _exerciseState.value = AddEditCurrentExerciseState(
                             title = "",
                             description = "",
                             exerciseType = ExerciseType.Reps,
                             isTitleHintVisible = true,
                             isDescriptionHintVisible = true
                         )
                     }
                 }
             }

             fun onEvent(event: AddEditExercisesEvent) {
                 when(event) {
                     is AddEditExercisesEvent.EnteredTitle -> {
                         _exerciseState.value = exerciseState.value.copy(
                             title = event.value,
                             isTitleHintVisible = event.value.isBlank()
                         )
                     }
                     is AddEditExercisesEvent.ChangeTitleFocus -> {
                         _exerciseState.value = exerciseState.value.copy(
                             isTitleHintVisible = !event.focusState.isFocused && exerciseState.value.title.isBlank()
                         )
                     }
                     is AddEditExercisesEvent.EnteredDescription -> {
                         _exerciseState.value = exerciseState.value.copy(
                             description = event.value,
                             isDescriptionHintVisible = event.value.isBlank()
                         )
                     }
                     is AddEditExercisesEvent.ChangeDescriptionFocus -> {
                         _exerciseState.value = exerciseState.value.copy(
                             isDescriptionHintVisible = !event.focusState.isFocused && exerciseState.value.description.isBlank()
                         )
                     }
                     is AddEditExercisesEvent.ChangeExerciseType -> {
                         _exerciseState.value = exerciseState.value.copy(
                             exerciseType = event.exerciseType
                         )
                     }
                     is AddEditExercisesEvent.SaveExercise -> {
                         viewModelScope.launch {
                             try {
                                 exerciseUseCases.addExercise(
                                     Exercise(
                                         name = exerciseState.value.title,
                                         description = exerciseState.value.description,
                                         exerciseType = exerciseState.value.exerciseType,
                                         id = exerciseState.value.exerciseId
                                     )
                                 )
                                 _eventFlow.emit(UiEvent.SaveExercise)
                             } catch (e: InvalidExerciseException) {
                                 _eventFlow.emit(
                                     UiEvent.ShowSnackbar(
                                         message = e.message ?: "Couldn't save exercise"
                                     )
                                 )
                             }
                         }
                     }
                 }
             }

             sealed class UiEvent {
                 data class ShowSnackbar(val message: String) : UiEvent()
                 object SaveExercise : UiEvent()
             }
         }package com.example.apptest.feature_train.presentation.add_edit_training

          data class AddEditCurrentTrainingState(
              val title: String = "",
              val date: Long = 0L,
              val failure: Boolean = false,
              val weights: String? = null,
              val trainingId: Int? = null,
              val isTitleHintVisible: Boolean = true,
              val isWeightHintVisible: Boolean = true
          )package com.example.apptest.feature_train.presentation.add_edit_training

           import androidx.compose.ui.focus.FocusState

           sealed class AddEditTrainingsEvent {
               data class EnteredTitle(val value: String) : AddEditTrainingsEvent()
               data class ChangeTitleFocus(val focusState: FocusState) : AddEditTrainingsEvent()
               data class EnteredWeight(val value: String) : AddEditTrainingsEvent()
               data class ChangeWeightFocus(val focusState: FocusState) : AddEditTrainingsEvent()
               data class ChangeFailureState(val value: Boolean) : AddEditTrainingsEvent()
               object SaveTraining : AddEditTrainingsEvent()
           }
package com.example.apptest.feature_train.presentation.add_edit_training

import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Save
import androidx.compose.material3.Checkbox
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.FloatingActionButton
import androidx.compose.material3.Icon
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Scaffold
import androidx.compose.material3.SnackbarHost
import androidx.compose.material3.SnackbarHostState
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.navigation.NavController
import com.example.apptest.feature_train.presentation.add_edit_training.components.TransparentHintTextField
import kotlinx.coroutines.flow.collectLatest
import kotlinx.coroutines.launch
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material3.*
import androidx.compose.runtime.*
import com.example.apptest.feature_train.domain.model.Exercise
import com.example.apptest.feature_train.domain.model.ExerciseType
import com.example.apptest.feature_train.domain.util.ExerciseOrder
import com.example.apptest.feature_train.domain.util.OrderType

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun AddEditTrainingsScreen(
    navController: NavController,
    viewModel: AddEditTrainingsViewModel = hiltViewModel()
) {
    val titleState = viewModel.trainingState.value
    val weightsState = viewModel.trainingState.value
    val failureState = viewModel.trainingState.value.failure
    val scaffoldState = remember { SnackbarHostState() }
    val scope = rememberCoroutineScope()

    // State for the exercise selection
    var expanded by remember { mutableStateOf(false) }
    var selectedExercise by remember { mutableStateOf<Exercise?>(null) }
    var exercises by remember { mutableStateOf(emptyList<Exercise>()) }

    // Collect exercises for the dropdown
    LaunchedEffect(key1 = viewModel) {
        viewModel.exerciseUseCases.getAllExercises(ExerciseOrder.Type(OrderType.Descending))
            .collect { exercises = it }
    }

    // State for showing the details dialog
    var showDialog by remember { mutableStateOf(false) }

    // Function to show the dialog
    fun onExerciseSelect(exercise: Exercise) {
        selectedExercise = exercise
        showDialog = true
    }

    // Dialog composable
    if (showDialog) {
        selectedExercise?.let { exercise ->
            ExerciseDetailsDialog(
                exercise = exercise,
                onDismiss = { showDialog = false },
                onConfirm = { reps, duration ->
                    showDialog = false
                    viewModel.addExerciseToTraining(exercise, reps, duration)
                }
            )
        }
    }

    // Collect UI events
    LaunchedEffect(key1 = true) {
        viewModel.eventFlow.collectLatest { event ->
            when (event) {
                is AddEditTrainingsViewModel.UiEvent.ShowSnackbar -> {
                    scope.launch {
                        scaffoldState.showSnackbar(message = event.message)
                    }
                }
                is AddEditTrainingsViewModel.UiEvent.SaveTraining -> {
                    navController.navigateUp()
                }
            }
        }
    }

    val addedExercises = viewModel.addedExercises.value // Access the value directly

    Scaffold(
        snackbarHost = { SnackbarHost(scaffoldState) },
        floatingActionButton = {
            FloatingActionButton(
                onClick = { viewModel.onEvent(AddEditTrainingsEvent.SaveTraining) },
                containerColor = MaterialTheme.colorScheme.primary
            ) {
                Icon(imageVector = Icons.Default.Save, contentDescription = "Save training")
            }
        }
    ) { padding ->
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp)
        ) {
            // Title input
            TransparentHintTextField(
                text = titleState.title,
                hint = "Enter title...",
                isHintVisible = titleState.isTitleHintVisible,
                onValueChange = { viewModel.onEvent(AddEditTrainingsEvent.EnteredTitle(it)) },
                onFocusChange = { viewModel.onEvent(AddEditTrainingsEvent.ChangeTitleFocus(it)) },
                textStyle = MaterialTheme.typography.headlineSmall,
                singleLine = true
            )

            Spacer(modifier = Modifier.height(16.dp))

            // Weights input
            TransparentHintTextField(
                text = weightsState.weights ?: "",
                hint = "Enter weights...",
                isHintVisible = weightsState.isWeightHintVisible,
                onValueChange = { viewModel.onEvent(AddEditTrainingsEvent.EnteredWeight(it)) },
                onFocusChange = { viewModel.onEvent(AddEditTrainingsEvent.ChangeWeightFocus(it)) },
                textStyle = MaterialTheme.typography.bodyMedium,
                singleLine = true
            )

            // Failure checkbox
            Row(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(8.dp),
                verticalAlignment = Alignment.CenterVertically
            ) {
                Checkbox(
                    checked = failureState,
                    onCheckedChange = { viewModel.onEvent(AddEditTrainingsEvent.ChangeFailureState(it)) }
                )
                Text("Failure")
            }

            // Button to add exercises
            Button(
                onClick = { expanded = !expanded },
                modifier = Modifier.fillMaxWidth()
            ) {
                Text("Add Exercise")
            }

            // Dropdown menu for exercise selection
            if (expanded) {
                AlertDialog(
                    onDismissRequest = { expanded = false },
                    title = { Text("Select an Exercise") },
                    text = {
                        LazyColumn(modifier = Modifier.fillMaxWidth()) {
                            items(exercises) { exercise ->
                                DropdownMenuItem(
                                    text = {
                                        Column {
                                            Text(exercise.name)
                                            when (exercise.exerciseType) {
                                                is ExerciseType.Reps -> Text("Reps")
                                                is ExerciseType.Duration -> Text("Duration")
                                            }
                                        }
                                    },
                                    onClick = {
                                        onExerciseSelect(exercise)
                                        expanded = false
                                    }
                                )
                            }
                        }
                    },
                    confirmButton = {
                        Button(onClick = { expanded = false }) {
                            Text("Cancel")
                        }
                    }
                )
            }

            // Display added exercises
            Spacer(modifier = Modifier.height(16.dp))
            Text("Added Exercises:", style = MaterialTheme.typography.headlineSmall)
            if (addedExercises.isEmpty()) {
                Text("No exercises added yet.", style = MaterialTheme.typography.bodyMedium)
            } else {
                LazyColumn {
                    items(addedExercises) { (exercise, trainingExercise) ->
                        Column(modifier = Modifier.padding(8.dp)) {
                            Text(exercise.name, style = MaterialTheme.typography.bodyLarge)
                            when (exercise.exerciseType) {
                                is ExerciseType.Reps -> {
                                    trainingExercise.reps?.let {
                                        Text("Reps: $it", style = MaterialTheme.typography.bodyMedium)
                                    }
                                }
                                is ExerciseType.Duration -> {
                                    trainingExercise.duration?.let {
                                        Text("Duration: $it seconds", style = MaterialTheme.typography.bodyMedium)
                                    }
                                }
                            }
                        }
                        HorizontalDivider()
                    }
                }
            }
        }
    }
}package com.example.apptest.feature_train.presentation.add_edit_training

 import androidx.compose.runtime.State
 import androidx.compose.runtime.mutableStateOf
 import androidx.lifecycle.SavedStateHandle
 import androidx.lifecycle.ViewModel
 import androidx.lifecycle.viewModelScope
 import com.example.apptest.feature_train.domain.model.InvalidTrainingException
 import com.example.apptest.feature_train.domain.model.Training
 import com.example.apptest.feature_train.domain.use_case.training_use_case.TrainingUseCases
 import dagger.hilt.android.lifecycle.HiltViewModel
 import kotlinx.coroutines.flow.MutableSharedFlow
 import kotlinx.coroutines.flow.asSharedFlow
 import kotlinx.coroutines.launch
 import javax.inject.Inject
 import com.example.apptest.feature_train.domain.model.Exercise
 import com.example.apptest.feature_train.domain.use_case.exercise_use_case.ExerciseUseCases
 import com.example.apptest.feature_train.domain.use_case.trainingExercise_use_case.TrainingExerciseUseCases
 import kotlinx.coroutines.flow.collect
 import kotlinx.coroutines.flow.map
 import kotlinx.coroutines.flow.launchIn
 import com.example.apptest.feature_train.domain.model.ExerciseType
 import com.example.apptest.feature_train.domain.model.TrainingExercise

 @HiltViewModel
 class AddEditTrainingsViewModel @Inject constructor(
     private val trainingUseCases: TrainingUseCases,
     val exerciseUseCases: ExerciseUseCases,
     private val trainingExerciseUseCases: TrainingExerciseUseCases,
     savedStateHandle: SavedStateHandle
 ) : ViewModel() {

     private val _trainingState = mutableStateOf(AddEditCurrentTrainingState())
     val trainingState: State<AddEditCurrentTrainingState> = _trainingState

     private val _eventFlow = MutableSharedFlow<UiEvent>()
     val eventFlow = _eventFlow.asSharedFlow()

     private var currentTrainingId: Int? = null

     private val _addedExercises = mutableStateOf<List<Pair<Exercise, TrainingExercise>>>(emptyList())
     val addedExercises: State<List<Pair<Exercise, TrainingExercise>>> = _addedExercises

     init {
         savedStateHandle.get<Int>("trainingId")?.let { trainingId ->
             if (trainingId != -1) {
                 viewModelScope.launch {
                     trainingUseCases.getTrainingById(trainingId)?.also { training ->
                         currentTrainingId = training.id
                         _trainingState.value = trainingState.value.copy(
                             title = training.title,
                             date = training.date,
                             failure = training.failure,
                             weights = training.weights?.toString(),
                             isTitleHintVisible = false,
                             isWeightHintVisible = training.weights == null
                         )
                     }
                     loadExercisesForTraining(trainingId)
                 }
             }
         }
     }

     private fun loadExercisesForTraining(trainingId: Int) {
         viewModelScope.launch {
             trainingExerciseUseCases.getExercisesForTraining(trainingId)
                 .map { trainingExercises ->
                     trainingExercises.mapNotNull { te ->
                         exerciseUseCases.getExerciseById(te.exerciseId)?.let { exercise ->
                             Pair(exercise, te)
                         }
                     }
                 }
                 .collect { exercisesWithDetails ->
                     _addedExercises.value = exercisesWithDetails
                 }
         }
     }

     fun onEvent(event: AddEditTrainingsEvent) {
         when (event) {
             is AddEditTrainingsEvent.EnteredTitle -> {
                 _trainingState.value = trainingState.value.copy(
                     title = event.value,
                     isTitleHintVisible = event.value.isBlank()
                 )
             }
             is AddEditTrainingsEvent.ChangeTitleFocus -> {
                 _trainingState.value = trainingState.value.copy(
                     isTitleHintVisible = !event.focusState.isFocused && trainingState.value.title.isBlank()
                 )
             }
             is AddEditTrainingsEvent.EnteredWeight -> {
                 _trainingState.value = trainingState.value.copy(
                     weights = event.value,
                     isWeightHintVisible = event.value.isBlank()
                 )
             }
             is AddEditTrainingsEvent.ChangeWeightFocus -> {
                 _trainingState.value = trainingState.value.copy(
                     isWeightHintVisible = !event.focusState.isFocused && trainingState.value.weights.isNullOrBlank()
                 )
             }
             is AddEditTrainingsEvent.ChangeFailureState -> {
                 _trainingState.value = trainingState.value.copy(
                     failure = event.value
                 )
             }
             is AddEditTrainingsEvent.SaveTraining -> {
                 viewModelScope.launch {
                     try {
                         if (trainingState.value.title.isBlank()) {
                             throw InvalidTrainingException("Training title cannot be empty.")
                         }

                         val weightsAsLong = trainingState.value.weights?.toLongOrNull()
                         if (trainingState.value.weights != null && weightsAsLong == null) {
                             throw InvalidTrainingException("Weights must be a valid number.")
                         }

                         trainingUseCases.addTraining(
                             Training(
                                 title = trainingState.value.title,
                                 date = trainingState.value.date,
                                 failure = trainingState.value.failure,
                                 weights = weightsAsLong,
                                 id = currentTrainingId ?: 0
                             )
                         )
                         _eventFlow.emit(UiEvent.SaveTraining)
                     } catch (e: InvalidTrainingException) {
                         _eventFlow.emit(
                             UiEvent.ShowSnackbar(
                                 message = e.message ?: "Couldn't save training"
                             )
                         )
                     }
                 }
             }
         }
     }

     fun addExerciseToTraining(exercise: Exercise, reps: Int?, duration: Int?) {
         viewModelScope.launch {
             currentTrainingId?.let { trainingId ->
                 try {
                     // Validate reps and duration based on exercise type
                     when (exercise.exerciseType) {
                         is ExerciseType.Reps -> {
                             if (reps == null || reps <= 0) {
                                 throw InvalidTrainingException("Reps must be greater than zero for Reps type exercises.")
                             }
                         }
                         is ExerciseType.Duration -> {
                             if (duration == null || duration <= 0) {
                                 throw InvalidTrainingException("Duration must be greater than zero for Duration type exercises.")
                             }
                         }
                     }

                     // Add the exercise to the training
                     val trainingExercise = com.example.apptest.feature_train.domain.model.TrainingExercise(
                         trainingId = trainingId,
                         exerciseId = exercise.id ?: 0,
                         reps = reps,
                         duration = duration
                     )

                     trainingExerciseUseCases.addTrainingExercise(
                         trainingExercise
                     )
                     loadExercisesForTraining(trainingId)
                 } catch (e: InvalidTrainingException) {
                     _eventFlow.emit(
                         UiEvent.ShowSnackbar(
                             message = e.message ?: "Couldn't add exercise to training"
                         )
                     )
                 }
             }
         }
     }

     sealed class UiEvent {
         data class ShowSnackbar(val message: String) : UiEvent()
         object SaveTraining : UiEvent()
     }
 }package com.example.apptest.feature_train.presentation.add_edit_training

  import androidx.compose.foundation.layout.Column
  import androidx.compose.foundation.text.KeyboardOptions
  import androidx.compose.material3.AlertDialog
  import androidx.compose.material3.Button
  import androidx.compose.material3.OutlinedTextField
  import androidx.compose.material3.Text
  import androidx.compose.runtime.Composable
  import androidx.compose.runtime.getValue
  import androidx.compose.runtime.mutableStateOf
  import androidx.compose.runtime.remember
  import androidx.compose.runtime.setValue
  import androidx.compose.ui.text.input.KeyboardType
  import com.example.apptest.feature_train.domain.model.Exercise
  import com.example.apptest.feature_train.domain.model.ExerciseType

  @Composable
  fun ExerciseDetailsDialog(
      exercise: Exercise,
      onDismiss: () -> Unit,
      onConfirm: (Int?, Int?) -> Unit
  ) {
      var reps by remember { mutableStateOf("") }
      var duration by remember { mutableStateOf("") }

      AlertDialog(
          onDismissRequest = onDismiss,
          title = { Text("Enter Details for ${exercise.name}") },
          text = {
              Column {
                  when (exercise.exerciseType) {
                      is ExerciseType.Reps -> {
                          OutlinedTextField(
                              value = reps,
                              onValueChange = { newValue ->
                                  reps = if (newValue.all { it.isDigit() }) newValue else reps
                              },
                              label = { Text("Reps") },
                              keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number)
                          )
                      }
                      is ExerciseType.Duration -> {
                          OutlinedTextField(
                              value = duration,
                              onValueChange = { newValue ->
                                  duration = if (newValue.all { it.isDigit() }) newValue else duration
                              },
                              label = { Text("Duration (in seconds)") },
                              keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number)
                          )
                      }
                  }
              }
          },
          confirmButton = {
              Button(onClick = {
                  onConfirm(reps.toIntOrNull(), duration.toIntOrNull())
              }) {
                  Text("Confirm")
              }
          },
          dismissButton = {
              Button(onClick = onDismiss) {
                  Text("Cancel")
              }
          }
      )
  }package com.example.apptest.feature_train.presentation.exercises.components

   import androidx.compose.foundation.layout.Column
   import androidx.compose.foundation.layout.Row
   import androidx.compose.foundation.layout.Spacer
   import androidx.compose.foundation.layout.fillMaxWidth
   import androidx.compose.foundation.layout.height
   import androidx.compose.foundation.layout.width
   import androidx.compose.material.icons.Icons
   import androidx.compose.material.icons.filled.Delete
   import androidx.compose.material3.Icon
   import androidx.compose.material3.IconButton
   import androidx.compose.material3.MaterialTheme
   import androidx.compose.material3.Text
   import androidx.compose.runtime.Composable
   import androidx.compose.ui.Alignment
   import androidx.compose.ui.Modifier
   import androidx.compose.ui.text.style.TextOverflow
   import androidx.compose.ui.unit.dp
   import com.example.apptest.feature_train.domain.model.Exercise
   import com.example.apptest.feature_train.domain.model.ExerciseType

   @Composable
   fun ExerciseItem(
       exercise: Exercise,
       modifier: Modifier = Modifier,
       onDeleteClick: () -> Unit
   ) {
       Row(
           modifier = modifier
               .fillMaxWidth(),
           verticalAlignment = Alignment.CenterVertically
       ) {
           Column(
               modifier = Modifier.weight(1f)
           ) {
               Text(
                   text = exercise.name,
                   style = MaterialTheme.typography.headlineSmall,
                   overflow = TextOverflow.Ellipsis,
                   maxLines = 1
               )
               Spacer(modifier = Modifier.height(4.dp))
               Text(
                   text = when (exercise.exerciseType) {
                       is ExerciseType.Reps -> "Reps"
                       is ExerciseType.Duration -> "Duration"
                   },
                   style = MaterialTheme.typography.bodyMedium
               )
           }
           IconButton(
               onClick = onDeleteClick,
           ) {
               Icon(
                   imageVector = Icons.Default.Delete,
                   contentDescription = "Delete exercise"
               )
           }
       }
   }package com.example.apptest.feature_train.presentation.exercises.components

    import androidx.compose.foundation.layout.Column
    import androidx.compose.foundation.layout.Row
    import androidx.compose.foundation.layout.Spacer
    import androidx.compose.foundation.layout.fillMaxWidth
    import androidx.compose.foundation.layout.width
    import androidx.compose.runtime.Composable
    import androidx.compose.ui.Modifier
    import androidx.compose.ui.unit.dp
    import com.example.apptest.feature_train.domain.util.ExerciseOrder
    import com.example.apptest.feature_train.domain.util.OrderType
    import com.example.apptest.feature_train.presentation.trainings.components.DefaultRadioButton

    @Composable
    fun ExerciseOrderSection(
        modifier: Modifier = Modifier,
        exerciseOrder: ExerciseOrder = ExerciseOrder.Type(OrderType.Descending), // Default order
        onOrderChange: (ExerciseOrder) -> Unit
    ) {
        Column(
            modifier = modifier
        ) {
            Row(
                modifier = Modifier.fillMaxWidth()
            ) {
                DefaultRadioButton(
                    text = "Title",
                    selected = exerciseOrder is ExerciseOrder.Title,
                    onSelect = { onOrderChange(ExerciseOrder.Title(exerciseOrder.orderType)) }
                )
                Spacer(modifier = Modifier.width(8.dp))
                DefaultRadioButton(
                    text = "Type",
                    selected = exerciseOrder is ExerciseOrder.Type,
                    onSelect = { onOrderChange(ExerciseOrder.Type(exerciseOrder.orderType)) }
                )
            }
            Spacer(modifier = Modifier.width(16.dp))
            Row(
                modifier = Modifier.fillMaxWidth()
            ) {
                DefaultRadioButton(
                    text = "Ascending",
                    selected = exerciseOrder.orderType is OrderType.Ascending,
                    onSelect = {
                        onOrderChange(exerciseOrder.copy(OrderType.Ascending))
                    }
                )
                Spacer(modifier = Modifier.width(8.dp))
                DefaultRadioButton(
                    text = "Descending",
                    selected = exerciseOrder.orderType is OrderType.Descending,
                    onSelect = {
                        onOrderChange(exerciseOrder.copy(OrderType.Descending))
                    }
                )
            }
        }
    }package com.example.apptest.feature_train.presentation.exercises

     import com.example.apptest.feature_train.domain.model.Exercise
     import com.example.apptest.feature_train.domain.util.ExerciseOrder

     sealed class ExercisesEvent {
         // when order has changed
         data class Order(val exerciseOrder: ExerciseOrder) : ExercisesEvent()
         // when exercise was deleted
         data class DeleteExercise(val exercise: Exercise) : ExercisesEvent()
         // when snackbar shows that user wishes to undo delete
         object RestoreExercise : ExercisesEvent()
         // when order section is clicked to roll out
         object ToggleOrderSection : ExercisesEvent()
     }
package com.example.apptest.feature_train.presentation.exercises

import androidx.compose.animation.AnimatedVisibility
import androidx.compose.animation.ExperimentalAnimationApi
import androidx.compose.animation.fadeIn
import androidx.compose.animation.fadeOut
import androidx.compose.animation.slideInVertically
import androidx.compose.animation.slideOutVertically
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.Sort
import androidx.compose.material.icons.filled.Add
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.FloatingActionButton
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Scaffold
import androidx.compose.material3.SnackbarHost
import androidx.compose.material3.SnackbarHostState
import androidx.compose.material3.SnackbarResult
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.navigation.NavController
import com.example.apptest.feature_train.presentation.exercises.components.ExerciseItem
import com.example.apptest.feature_train.presentation.exercises.components.ExerciseOrderSection
import com.example.apptest.feature_train.presentation.util.Screen
import kotlinx.coroutines.launch

@OptIn(ExperimentalAnimationApi::class, ExperimentalMaterial3Api::class)
@Composable
fun ExercisesScreen(
    navController: NavController,
    viewModel: ExercisesViewModel = hiltViewModel()
) {
    val state = viewModel.state.value
    val scaffoldState = remember { SnackbarHostState() }
    val scope = rememberCoroutineScope()

    Scaffold(
        floatingActionButton = {
            FloatingActionButton(
                onClick = {
                    navController.navigate(Screen.AddEditExerciseScreen.route)
                },
                containerColor = MaterialTheme.colorScheme.primary
            ) {
                Icon(imageVector = Icons.Default.Add, contentDescription = "Add exercise")
            }
        },
        snackbarHost = { SnackbarHost(scaffoldState) }
    ) { innerPadding ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(innerPadding)
        ) {
            Row(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(16.dp),
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.CenterVertically
            ) {
                Text(
                    text = "Your exercises",
                    style = MaterialTheme.typography.headlineMedium
                )
                IconButton(
                    onClick = {
                        viewModel.onEvent(ExercisesEvent.ToggleOrderSection)
                    },
                ) {
                    Icon(
                        imageVector = Icons.AutoMirrored.Default.Sort,
                        contentDescription = "Sort"
                    )
                }
            }
            AnimatedVisibility(
                visible = state.isOrderSectionVisible,
                enter = fadeIn() + slideInVertically(),
                exit = fadeOut() + slideOutVertically()
            ) {
                ExerciseOrderSection(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(16.dp),
                    exerciseOrder = state.exerciseOrder,
                    onOrderChange = {
                        viewModel.onEvent(ExercisesEvent.Order(it))
                    }
                )
            }
            Spacer(modifier = Modifier.height(16.dp))
            LazyColumn(modifier = Modifier.fillMaxSize().padding(horizontal = 16.dp)) {
                items(state.exercises) { exercise ->
                    ExerciseItem(
                        exercise = exercise,
                        modifier = Modifier
                            .fillMaxWidth()
                            .clickable {
                                navController.navigate(
                                    Screen.AddEditExerciseScreen.route +
                                            "?exerciseId=${exercise.id}"
                                )
                            },
                        onDeleteClick = {
                            viewModel.onEvent(ExercisesEvent.DeleteExercise(exercise))
                            scope.launch {
                                val result = scaffoldState.showSnackbar(
                                    message = "Exercise deleted",
                                    actionLabel = "Undo"
                                )
                                if (result == SnackbarResult.ActionPerformed) {
                                    viewModel.onEvent(ExercisesEvent.RestoreExercise)
                                }
                            }
                        }
                    )
                    Spacer(modifier = Modifier.height(16.dp))
                }
            }
        }
    }
}package com.example.apptest.feature_train.presentation.exercises

 import com.example.apptest.feature_train.domain.model.Exercise
 import com.example.apptest.feature_train.domain.util.OrderType
 import com.example.apptest.feature_train.domain.util.ExerciseOrder

 data class ExercisesState(
     // list of exercise items
     val exercises: List<Exercise> = emptyList(),
     // train list order
     val exerciseOrder: ExerciseOrder = ExerciseOrder.Title(OrderType.Descending),
     val isOrderSectionVisible: Boolean = false
 )package com.example.apptest.feature_train.presentation.exercises

  import androidx.compose.runtime.State
  import androidx.compose.runtime.mutableStateOf
  import androidx.lifecycle.ViewModel
  import androidx.lifecycle.viewModelScope
  import com.example.apptest.feature_train.domain.model.Exercise
  import com.example.apptest.feature_train.domain.use_case.exercise_use_case.ExerciseUseCases
  import com.example.apptest.feature_train.domain.util.ExerciseOrder
  import com.example.apptest.feature_train.domain.util.OrderType
  import dagger.hilt.android.lifecycle.HiltViewModel
  import kotlinx.coroutines.Job
  import kotlinx.coroutines.flow.launchIn
  import kotlinx.coroutines.flow.onEach
  import kotlinx.coroutines.launch
  import javax.inject.Inject

  // used to inject a VM in a specific screen component
  @HiltViewModel
  class ExercisesViewModel @Inject constructor(
      private val exerciseUseCases: ExerciseUseCases
  ) : ViewModel() {

      private var recentlyDeletedExercise: Exercise? = null
      private var getExercisesJob: Job? = null

      // state of this screen
      private val _state = mutableStateOf(ExercisesState())
      val state: State<ExercisesState> = _state

      init {
          getExercises(ExerciseOrder.Title(OrderType.Descending))
      }

      fun onEvent(event: ExercisesEvent) {
          when (event) {
              is ExercisesEvent.Order -> {
                  // ::class is used to compare not equality of links, but of class types,
                  // since exerciseOrder is a class, not an object like orderType
                  if (state.value.exerciseOrder::class == event.exerciseOrder::class &&
                      state.value.exerciseOrder.orderType == event.exerciseOrder.orderType) {
                      return
                  }
                  getExercises(event.exerciseOrder)
              }
              is ExercisesEvent.DeleteExercise -> {
                  viewModelScope.launch {
                      exerciseUseCases.deleteExercise(event.exercise)
                      recentlyDeletedExercise = event.exercise
                  }
              }
              is ExercisesEvent.RestoreExercise -> {
                  viewModelScope.launch {
                      exerciseUseCases.addExercise(recentlyDeletedExercise ?: return@launch)
                      recentlyDeletedExercise = null
                  }
              }
              // just hides and reveals order button
              is ExercisesEvent.ToggleOrderSection -> {
                  _state.value = state.value.copy(
                      isOrderSectionVisible = !state.value.isOrderSectionVisible
                  )
              }
          }
      }

      private fun getExercises(exerciseOrder: ExerciseOrder) {
          // if already trying to retrieve exercises from Dao, cancel attempt
          getExercisesJob?.cancel()
          getExercisesJob = exerciseUseCases.getAllExercises(exerciseOrder)
              .onEach { exercises ->
                  _state.value = state.value.copy(
                      exercises = exercises,
                      exerciseOrder = exerciseOrder
                      // no selection of order section is specified, cause we wish to keep it consistent
                  )
              }.launchIn(viewModelScope)
      }
  }
package com.example.apptest.feature_train.presentation.trainingExercises


import com.example.apptest.feature_train.domain.model.TrainingExercise


sealed class TrainingExercisesEvent {
    data class DeleteTrainingExercise(val trainingExercise: TrainingExercise): TrainingExercisesEvent()
    object RestoreExerciseTraining: TrainingExercisesEvent()
}package com.example.apptest.feature_train.presentation.trainingExercises

 import androidx.compose.runtime.Composable
 import androidx.hilt.navigation.compose.hiltViewModel
 import androidx.navigation.NavController
 import com.example.apptest.feature_train.presentation.trainingExercises.TrainingExercisesViewModel

 @Composable
 fun TrainingExercisesScreen(
     navController: NavController,
     viewModel: TrainingExercisesViewModel = hiltViewModel()
 ) {
 }package com.example.apptest.feature_train.presentation.trainingExercises

  import com.example.apptest.feature_train.domain.model.TrainingExercise

  data class TrainingExercisesState (
      val trainingExercises: List<TrainingExercise> = emptyList()
  )package com.example.apptest.feature_train.presentation.trainingExercises
   import androidx.compose.runtime.State
   import androidx.compose.runtime.mutableStateOf
   import androidx.lifecycle.SavedStateHandle
   import androidx.lifecycle.ViewModel
   import androidx.lifecycle.viewModelScope
   import com.example.apptest.feature_train.domain.model.TrainingExercise
   import com.example.apptest.feature_train.domain.use_case.trainingExercise_use_case.TrainingExerciseUseCases
   import kotlinx.coroutines.Job
   import kotlinx.coroutines.flow.launchIn
   import kotlinx.coroutines.flow.onEach
   import kotlinx.coroutines.launch
   import javax.inject.Inject

   class TrainingExercisesViewModel @Inject constructor(
       private val trainingExerciseUseCases: TrainingExerciseUseCases,
       savedStateHandle: SavedStateHandle

   ): ViewModel(){
       private var recentlyDeletedTrainingExercise: TrainingExercise? = null
       private var getTrainingExercisesJob: Job? = null

       // state of this screen
       private val _state = mutableStateOf(TrainingExercisesState())
       val state: State<TrainingExercisesState> = _state
       private var currentTrainingId: Int? = null

       init {
           savedStateHandle.get<Int>("trainingId")?.let { trainingId ->
               if(trainingId != -1){
                   viewModelScope.launch {
                       currentTrainingId?.let { getTrainingExercises(it) }
                   }
               }
           }
       }

       fun onEvent(event: TrainingExercisesEvent){
           when(event){
               is TrainingExercisesEvent.DeleteTrainingExercise -> {
                   viewModelScope.launch {
                       trainingExerciseUseCases.deleteTrainingExercise(event.trainingExercise)
                       recentlyDeletedTrainingExercise = event.trainingExercise
                   }
               }
               is TrainingExercisesEvent.RestoreExerciseTraining -> {
                   viewModelScope.launch {
                       trainingExerciseUseCases.addTrainingExercise(recentlyDeletedTrainingExercise ?: return@launch)
                       recentlyDeletedTrainingExercise = null
                   }
               }
           }
       }

       private fun getTrainingExercises(currentTrainingId: Int) {
           getTrainingExercisesJob?.cancel()
           getTrainingExercisesJob = trainingExerciseUseCases.getExercisesForTraining(currentTrainingId)
               .onEach { trainingExercises ->
                   _state.value = state.value.copy(
                       trainingExercises = trainingExercises
                   )
               }.launchIn(viewModelScope)
       }
   }package com.example.apptest.feature_train.presentation.trainings.components

    import androidx.compose.foundation.layout.Box
    import androidx.compose.foundation.layout.Column
    import androidx.compose.foundation.layout.Row
    import androidx.compose.foundation.layout.Spacer
    import androidx.compose.foundation.layout.fillMaxSize
    import androidx.compose.foundation.layout.fillMaxWidth
    import androidx.compose.foundation.layout.height
    import androidx.compose.foundation.layout.padding
    import androidx.compose.foundation.layout.width
    import androidx.compose.material.icons.Icons
    import androidx.compose.material.icons.filled.Delete
    import androidx.compose.material3.Icon
    import androidx.compose.material3.IconButton
    import androidx.compose.material3.MaterialTheme
    import androidx.compose.material3.Text
    import androidx.compose.runtime.Composable
    import androidx.compose.ui.Alignment
    import androidx.compose.ui.Modifier
    import androidx.compose.ui.graphics.Color
    import androidx.compose.ui.text.style.TextOverflow
    import androidx.compose.ui.unit.dp
    import com.example.apptest.feature_train.domain.model.Training

    @Composable
    fun TrainingItem(
        training: Training,
        modifier: Modifier = Modifier,
        onDeleteClick: () -> Unit
    ) {
        Box(
            modifier = modifier
        ) {
            Column(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(16.dp)
                    .padding(end = 32.dp)
            ) {
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Text(
                        text = training.title,
                        style = MaterialTheme.typography.headlineSmall,
                        color = MaterialTheme.colorScheme.onSurface,
                        maxLines = 1,
                        overflow = TextOverflow.Ellipsis
                    )
                }
                if (training.failure) {
                    Spacer(modifier = Modifier.width(8.dp))
                    Text("Failure", color = Color.Red)
                }
                Spacer(modifier = Modifier.height(8.dp))
                Text(
                    text = "Weights: ${training.weights ?: "N/A"}",
                    style = MaterialTheme.typography.bodyMedium,
                    color = MaterialTheme.colorScheme.onSurface,
                    maxLines = 1,
                    overflow = TextOverflow.Ellipsis
                )
            }
            IconButton(
                onClick = onDeleteClick,
                modifier = Modifier.align(Alignment.BottomEnd)
            ) {
                Icon(
                    imageVector = Icons.Default.Delete,
                    contentDescription = "Delete training",
                    tint = MaterialTheme.colorScheme.onSurface
                )
            }
        }
    }package com.example.apptest.feature_train.presentation.trainings

     import com.example.apptest.feature_train.domain.model.Training
     import com.example.apptest.feature_train.domain.util.TrainingOrder


     sealed class TrainingsEvent {
         // when order has changed
         data class Order(val trainingOrder: TrainingOrder): TrainingsEvent()
         // when training was deleted
         data class DeleteTraining (val training: Training): TrainingsEvent()
         // when snackbar showed user wish to undo delete
         object RestoreTraining: TrainingsEvent()
         // when orderSection is clicked to roll out
         object ToggleOrderSection: TrainingsEvent()
     }package com.example.apptest.feature_train.presentation.trainings

      import androidx.compose.animation.AnimatedVisibility
      import androidx.compose.animation.ExperimentalAnimationApi
      import androidx.compose.animation.fadeIn
      import androidx.compose.animation.fadeOut
      import androidx.compose.animation.slideInVertically
      import androidx.compose.animation.slideOutVertically
      import androidx.compose.foundation.clickable
      import androidx.compose.foundation.layout.Arrangement
      import androidx.compose.foundation.layout.Column
      import androidx.compose.foundation.layout.PaddingValues
      import androidx.compose.foundation.layout.Row
      import androidx.compose.foundation.layout.Spacer
      import androidx.compose.foundation.layout.fillMaxSize
      import androidx.compose.foundation.layout.fillMaxWidth
      import androidx.compose.foundation.layout.height
      import androidx.compose.foundation.layout.padding
      import androidx.compose.foundation.lazy.LazyColumn
      import androidx.compose.foundation.lazy.items
      import androidx.compose.material.icons.Icons
      import androidx.compose.material.icons.automirrored.filled.Sort
      import androidx.compose.material.icons.filled.Add
      import androidx.compose.material.icons.filled.Sort
      import androidx.compose.material3.Button
      import androidx.compose.material3.ExperimentalMaterial3Api
      import androidx.compose.material3.FloatingActionButton
      import androidx.compose.material3.Icon
      import androidx.compose.material3.IconButton
      import androidx.compose.material3.MaterialTheme
      import androidx.compose.material3.Scaffold
      import androidx.compose.material3.SnackbarHost
      import androidx.compose.material3.SnackbarHostState
      import androidx.compose.material3.SnackbarResult
      import androidx.compose.material3.Text
      import androidx.compose.runtime.Composable
      import androidx.compose.runtime.remember
      import androidx.compose.runtime.rememberCoroutineScope
      import androidx.compose.ui.Alignment
      import androidx.compose.ui.Modifier
      import androidx.compose.ui.unit.dp
      import androidx.hilt.navigation.compose.hiltViewModel
      import androidx.navigation.NavController
      import com.example.apptest.feature_train.presentation.trainings.components.OrderSection
      import com.example.apptest.feature_train.presentation.trainings.components.TrainingItem
      import com.example.apptest.feature_train.presentation.util.Screen
      import kotlinx.coroutines.launch

      @OptIn(ExperimentalAnimationApi::class, ExperimentalMaterial3Api::class)
      @Composable
      fun TrainingsScreen(
          navController: NavController,
          viewModel: TrainingsViewModel = hiltViewModel()
      ) {
          // assigned viewmodel state to local layout objects
          val state = viewModel.state.value
          val scaffoldState = remember { SnackbarHostState() }
          val scope = rememberCoroutineScope()

          Scaffold(
              floatingActionButton = {
                  FloatingActionButton(
                      onClick = {
                          //TODO: navigation is not implemented yet
                          navController.navigate(Screen.AddEditTrainingScreen.route)
                      },
                      containerColor = MaterialTheme.colorScheme.primary
                  ) {
                      Icon(imageVector = Icons.Default.Add, contentDescription = "Add training")
                  }
              },
              snackbarHost = { SnackbarHost(scaffoldState) }
          ) { innerPadding ->
              Column(
                  modifier = Modifier
                      .fillMaxSize()
                      .padding(innerPadding) // Apply the innerPadding provided by Scaffold
              ) {
                  Row(
                      modifier = Modifier
                          .fillMaxWidth()
                          .padding(16.dp),
                      horizontalArrangement = Arrangement.SpaceBetween,
                      verticalAlignment = Alignment.CenterVertically
                  ) {
                      Text(
                          text = "Your trainings",
                          style = MaterialTheme.typography.headlineMedium
                      )
                      IconButton(
                          onClick = {
                              // changed the state of oredersection visibility to opposite
                              viewModel.onEvent(TrainingsEvent.ToggleOrderSection)
                          },
                      ) {
                          Icon(
                              imageVector = Icons.AutoMirrored.Default.Sort,
                              contentDescription = "Sort"
                          )
                      }
                  }
                  AnimatedVisibility(
                      visible = state.isOrderSectionVisible,
                      enter = fadeIn() + slideInVertically(),
                      exit = fadeOut() + slideOutVertically()
                  ) {
                      OrderSection(
                          modifier = Modifier
                              .fillMaxWidth()
                              .padding(16.dp),
                          trainingOrder = state.trainingOrder,
                          onOrderChange = {
                              // when any button of section pressed calls event in VM
                              viewModel.onEvent(TrainingsEvent.Order(it))
                          }
                      )
                  }
                  Spacer(modifier = Modifier.height(16.dp))
                  // Navigate to ExercisesScreen
                  Button(
                      onClick = { navController.navigate(Screen.ExercisesScreen.route) },
                      modifier = Modifier.padding(16.dp)
                  ) {
                      Text("Go to Exercises")
                  }
                  LazyColumn(modifier = Modifier.fillMaxSize().padding(horizontal = 16.dp)) {
                      // takes trainings from outer, changed state
                      items(state.trainings) { training ->
                          TrainingItem(
                              training = training,
                              modifier = Modifier
                                  .fillMaxWidth()
                                  .clickable {
                                      //ToDo: navigation is not implemented yet
                                      navController.navigate(
                                          Screen.AddEditTrainingScreen.route +
                                                  "?trainingId=${training.id}"
                                      )
                                  },
                              onDeleteClick = {
                                  viewModel.onEvent(TrainingsEvent.DeleteTraining(training))
                                  scope.launch {
                                      val result = scaffoldState.showSnackbar(
                                          message = "Training deleted",
                                          actionLabel = "Undo"
                                      )
                                      if (result == SnackbarResult.ActionPerformed) {
                                          viewModel.onEvent(TrainingsEvent.RestoreTraining)
                                      }
                                  }
                              }
                          )
                          Spacer(modifier = Modifier.height(16.dp))
                      }
                  }
              }
          }
      }package com.example.apptest.feature_train.presentation.trainings

       import com.example.apptest.feature_train.domain.model.Training
       import com.example.apptest.feature_train.domain.util.OrderType
       import com.example.apptest.feature_train.domain.util.TrainingOrder

       data class TrainingsState(
           // list of training items
           val trainings: List<Training> = emptyList(),
           // train list order
           val trainingOrder: TrainingOrder = TrainingOrder.Date(OrderType.Descending),
           val isOrderSectionVisible: Boolean = false
       )package com.example.apptest.feature_train.presentation.trainings

        import androidx.compose.runtime.State
        import androidx.compose.runtime.mutableStateOf
        import androidx.lifecycle.ViewModel
        import androidx.lifecycle.viewModelScope
        import com.example.apptest.feature_train.domain.model.Training
        import com.example.apptest.feature_train.domain.use_case.training_use_case.TrainingUseCases
        import com.example.apptest.feature_train.domain.util.OrderType
        import com.example.apptest.feature_train.domain.util.TrainingOrder
        import dagger.hilt.android.lifecycle.HiltViewModel
        import kotlinx.coroutines.Job
        import kotlinx.coroutines.flow.launchIn
        import kotlinx.coroutines.flow.onEach
        import kotlinx.coroutines.launch
        import javax.inject.Inject


        // used to inject a VM in a specific screen component
        @HiltViewModel
        class TrainingsViewModel @Inject constructor(
            private val trainingsUseCases: TrainingUseCases
            ): ViewModel(){

            private var recentlyDeletedTraining: Training? = null
            private var getTrainingsJob: Job? = null

            // state of this screen
            private val _state = mutableStateOf(TrainingsState())
            val state: State<TrainingsState> = _state

            init {
                getTrainings(TrainingOrder.Date(OrderType.Descending))
            }

            fun onEvent(event: TrainingsEvent){
                when(event){
                    is TrainingsEvent.Order -> {
                        // ::class is used to compare not equality of links, but of class types,
                        // since trainorder is a class, not object like ordertype
                        if (state.value.trainingOrder::class == event.trainingOrder::class &&
                            state.value.trainingOrder.orderType == event.trainingOrder.orderType)
                        {
                            return
                        }
                        getTrainings(event.trainingOrder)
                    }
                    is TrainingsEvent.DeleteTraining -> {
                        viewModelScope.launch {
                            trainingsUseCases.deleteTraining(event.training)
                            recentlyDeletedTraining = event.training
                        }
                    }
                    is TrainingsEvent.RestoreTraining -> {
                        viewModelScope.launch {
                            trainingsUseCases.addTraining(recentlyDeletedTraining ?: return@launch)
                            recentlyDeletedTraining = null
                        }
                    }
                    // just hides and reveals order bttn
                    is TrainingsEvent.ToggleOrderSection -> {
                        _state.value = state.value.copy(
                            isOrderSectionVisible = !state.value.isOrderSectionVisible
                        )
                    }
                }
            }

            private fun getTrainings(trainingOrder: TrainingOrder){
                // if already trying to retrieve trainings from Dao, cancel attempt
                getTrainingsJob?.cancel()
                getTrainingsJob = trainingsUseCases.getAllTrainings(trainingOrder)
                    .onEach {trainings ->
                        _state.value = state.value.copy(
                            trainings = trainings,
                            trainingOrder = trainingOrder
                            // no selection of ordersection is specified, cause we wish to keep it consistent
                        )
                    }.launchIn(viewModelScope)
            }
        }
package com.example.apptest.feature_train.presentation.util

sealed class Screen (
    val route: String
){
    object TrainingsScreen: Screen("trainings_screen")
    object AddEditTrainingScreen: Screen ("add_edit_training_screen")
    object AddEditExerciseScreen: Screen ("add_edit_exercise_screen")
    object ExercisesScreen: Screen("exercises_screen")
    object TrainingExercisesScreen: Screen("trainingExercises_screen")
}package com.example.apptest

 import android.os.Bundle
 import androidx.activity.ComponentActivity
 import androidx.activity.compose.setContent
 import androidx.compose.animation.ExperimentalAnimationApi
 import androidx.compose.material3.MaterialTheme
 import androidx.compose.material3.Surface
 import androidx.navigation.NavType
 import androidx.navigation.compose.NavHost
 import androidx.navigation.compose.composable
 import androidx.navigation.compose.rememberNavController
 import androidx.navigation.navArgument
 import com.example.apptest.feature_train.presentation.add_edit_exercise.AddEditExercisesScreen
 import com.example.apptest.feature_train.presentation.add_edit_training.AddEditTrainingsScreen
 import com.example.apptest.feature_train.presentation.exercises.ExercisesScreen
 import com.example.apptest.feature_train.presentation.trainingExercises.TrainingExercisesScreen
 import com.example.apptest.feature_train.presentation.trainings.TrainingsScreen
 import com.example.apptest.feature_train.presentation.util.Screen
 import com.example.apptest.ui.theme.AppTestTheme
 import dagger.hilt.android.AndroidEntryPoint

 @AndroidEntryPoint
 class MainActivity : ComponentActivity() {
     @OptIn(ExperimentalAnimationApi::class)
     override fun onCreate(savedInstanceState: Bundle?) {
         super.onCreate(savedInstanceState)
         setContent {
             AppTestTheme {
                 Surface(
                     color = MaterialTheme.colorScheme.background
                 ) {
                     val navController = rememberNavController()
                     NavHost(
                         navController = navController,
                         startDestination = Screen.TrainingsScreen.route
                     ) {
                         composable(route = Screen.TrainingsScreen.route) {
                             TrainingsScreen(navController = navController)
                         }
                         composable(
                             route = Screen.AddEditTrainingScreen.route +
                                     "?trainingId={trainingId}",
                             arguments = listOf(
                                 navArgument(
                                     name = "trainingId"
                                 ) {
                                     type = NavType.IntType
                                     defaultValue = -1
                                 }
                             )
                         ) {
                             AddEditTrainingsScreen(
                                 navController = navController
                             )
                         }
                         // TRAINING_EXERCISES
                         composable(
                             route = Screen.TrainingExercisesScreen.route +
                                     "?trainingId={trainingId}",
                             arguments = listOf(
                                 navArgument(
                                     name = "trainingId"
                                 ){
                                     type = NavType.IntType
                                     defaultValue = -1
                                 }
                             )
                         ){
                             TrainingExercisesScreen(
                                 navController = navController
                             )
                         }
                         // EXERCISES
                         composable(route = Screen.ExercisesScreen.route) {
                             ExercisesScreen(navController = navController)
                         }
                         composable(
                             route = Screen.AddEditExerciseScreen.route +
                                     "?exerciseId={exerciseId}",
                             arguments = listOf(
                                 navArgument(
                                     name = "exerciseId"
                                 ) {
                                     type = NavType.IntType
                                     defaultValue = -1
                                 }
                             )
                         ) {
                             AddEditExercisesScreen(
                                 navController = navController
                             )
                         }
                     }
                 }
             }
         }
     }
 }package com.example.apptest

  import android.app.Application
  import dagger.hilt.android.HiltAndroidApp

  // Don't forget tot specify this file ass appname in the manifest file!!!
  // android:name=".TrainingApp"
  @HiltAndroidApp
  class TrainingApp : Application() {
  }