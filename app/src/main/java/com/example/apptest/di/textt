package com.example.apptest.di

import android.app.Application
import androidx.room.Room
import com.example.apptest.feature_train.data.data_source.TrainDatabase
import com.example.apptest.feature_train.data.repository.TrainingRepositoryImpl
import com.example.apptest.feature_train.domain.repository.TrainingRepository
import com.example.apptest.feature_train.domain.use_case.training_use_case.AddTraining
import com.example.apptest.feature_train.domain.use_case.training_use_case.DeleteTraining
import com.example.apptest.feature_train.domain.use_case.training_use_case.GetAllTrainings
import com.example.apptest.feature_train.domain.use_case.training_use_case.GetTrainingById
import com.example.apptest.feature_train.domain.use_case.training_use_case.TrainingUseCases
import com.example.apptest.feature_train.domain.use_case.training_use_case.UpdateTraining
import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.components.SingletonComponent
import javax.inject.Singleton


@Module
@InstallIn(SingletonComponent::class)
object AppModule {

    @Provides
    @Singleton
    fun provideTrainDatabase(app: Application) : TrainDatabase{
        return Room.databaseBuilder(
            app,
            TrainDatabase::class.java,
            TrainDatabase.DATABASE_NAME
        ).build()
    }

    @Provides
    @Singleton
    fun provideTrainingRepository(db: TrainDatabase): TrainingRepository {
        // when database created an instance of trainingDao is created as well and consumed here
        return TrainingRepositoryImpl(db.trainingDao)
    }

    @Provides
    @Singleton
    fun provideTrainingUseCases(repository: TrainingRepository) : TrainingUseCases {
        return TrainingUseCases(
            addTraining = AddTraining(repository),
            deleteTraining = DeleteTraining(repository),
            getAllTrainings = GetAllTrainings(repository),
            getTrainingById = GetTrainingById(repository),
            updateTraining = UpdateTraining(repository)
        )
    }
}

package com.example.apptest.feature_train.data.data_source

import androidx.room.Database
import androidx.room.RoomDatabase
import com.example.apptest.feature_train.domain.model.Training

@Database(
    entities = [Training::class],
    version = 1, // Simplified version
)
abstract class TrainDatabase : RoomDatabase() {
    abstract val trainingDao: TrainingDao

    companion object {
        const val DATABASE_NAME = "trainings_db"
    }
}

package com.example.apptest.feature_train.data.data_source

import androidx.room.Dao
import androidx.room.Delete
import androidx.room.Insert
import androidx.room.OnConflictStrategy
import androidx.room.Query
import androidx.room.Update
import com.example.apptest.feature_train.domain.model.Training
import kotlinx.coroutines.flow.Flow


@Dao
interface TrainingDao {
    @Query("SELECT * FROM Training")
    fun getAllTrainings(): Flow<List<Training>>

    @Query("SELECT * FROM Training WHERE id = :trainingId")
    suspend fun getTrainingById(trainingId: Int): Training? // Suspend function is correct here

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun addTraining(training: Training) // Suspend function is correct here

    @Update
    suspend fun updateTraining(training: Training) // Suspend function is correct here

    @Delete
    suspend fun deleteTraining(training: Training) // Suspend function is correct here
}

package com.example.apptest.feature_train.data.repository

import com.example.apptest.feature_train.data.data_source.TrainingDao
import com.example.apptest.feature_train.domain.model.Training
import com.example.apptest.feature_train.domain.repository.TrainingRepository
import kotlinx.coroutines.flow.Flow

class TrainingRepositoryImpl(
    private val dao: TrainingDao
) : TrainingRepository {

    override fun getAllTrainings(): Flow<List<Training>> {
        return dao.getAllTrainings()
    }

    override suspend fun getTrainingById(trainingId: Int): Training? {
        return dao.getTrainingById(trainingId)
    }

    override suspend fun addTraining(training: Training) {
        dao.addTraining(training)
    }

    override suspend fun updateTraining(training: Training) {
        dao.updateTraining(training)
    }

    override suspend fun deleteTraining(training: Training) {
        dao.deleteTraining(training)
    }
}

package com.example.apptest.feature_train.domain.model

import androidx.room.Entity
import androidx.room.PrimaryKey

@Entity
data class Training(
    val title: String,
    val date: Long,
    val failure: Boolean = false,
    val weights: Int? = null,
    @PrimaryKey(autoGenerate = true) val id: Int = 0 // Auto-generate ID
)

class InvalidTrainingException(message: String) : Exception(message)

package com.example.apptest.feature_train.domain.repository

import com.example.apptest.feature_train.domain.model.Training
import kotlinx.coroutines.flow.Flow

interface TrainingRepository {

    fun getAllTrainings(): Flow<List<Training>>

    suspend fun getTrainingById(trainingId: Int): Training?

    suspend fun addTraining(training: Training)

    suspend fun updateTraining(training: Training)

    suspend fun deleteTraining(training: Training)
}

package com.example.apptest

import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.animation.ExperimentalAnimationApi
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Surface
import androidx.navigation.NavType
import androidx.navigation.compose.NavHost
import androidx.navigation.compose.composable
import androidx.navigation.compose.rememberNavController
import com.example.apptest.feature_train.presentation.trainings.TrainingsScreen
import com.example.apptest.feature_train.presentation.util.Screen
import com.example.apptest.ui.theme.AppTestTheme
import dagger.hilt.android.AndroidEntryPoint

@AndroidEntryPoint
class MainActivity : ComponentActivity() {
    @OptIn(ExperimentalAnimationApi::class)
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            AppTestTheme {
                Surface(
                    color = MaterialTheme.colorScheme.background
                ) {
                    val navController = rememberNavController()
                    NavHost(
                        navController = navController,
                        startDestination = Screen.TrainingsScreen.route
                    ) {
                        composable(route = Screen.TrainingsScreen.route) {
                            TrainingsScreen(navController = navController)
                        }
                    }
                }
            }
        }
    }
}

package com.example.apptest

import android.app.Application
import dagger.hilt.android.HiltAndroidApp


@HiltAndroidApp
class TrainingApp : Application() {
}

build gradle kts app level:
plugins {
    alias(libs.plugins.android.application)
    alias(libs.plugins.kotlin.android)
    alias(libs.plugins.kotlin.compose)
    id("kotlin-kapt")
    id("com.google.dagger.hilt.android")
}

android {
    namespace = "com.example.apptest"
    compileSdk = 35

    defaultConfig {
        applicationId = "com.example.apptest"
        minSdk = 27
        targetSdk = 34
        versionCode = 1
        versionName = "1.0"

        testInstrumentationRunner = "androidx.test.runner.AndroidJUnitRunner"
    }

    buildTypes {
        release {
            isMinifyEnabled = false
            proguardFiles(
                getDefaultProguardFile("proguard-android-optimize.txt"),
                "proguard-rules.pro"
            )
        }
    }
    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_17
        targetCompatibility = JavaVersion.VERSION_17
    }
    kotlinOptions {
        jvmTarget = "17"
    }
    buildFeatures {
        compose = true
    }
}

dependencies {

    implementation(libs.androidx.core.ktx)
    implementation(libs.androidx.lifecycle.runtime.ktx)
    implementation(libs.androidx.activity.compose)
    implementation(platform(libs.androidx.compose.bom))
    implementation(libs.androidx.ui)
    implementation(libs.androidx.ui.graphics)
    implementation(libs.androidx.ui.tooling.preview)
    implementation(libs.androidx.material3)
    implementation(libs.androidx.databinding.adapters)
    testImplementation(libs.junit)
    androidTestImplementation(libs.androidx.junit)
    androidTestImplementation(libs.androidx.espresso.core)
    androidTestImplementation(platform(libs.androidx.compose.bom))
    androidTestImplementation(libs.androidx.ui.test.junit4)
    debugImplementation(libs.androidx.ui.tooling)
    debugImplementation(libs.androidx.ui.test.manifest)

    //dagger
    implementation(libs.hilt.android)
    kapt(libs.hilt.android.compiler)

    ////////////////
    //ROOM DEPENDENCIES:
    val room_version = "2.6.1"

    implementation("androidx.room:room-runtime:$room_version")

    // If this project uses any Kotlin source, use Kotlin Symbol Processing (KSP)
    // See Add the KSP plugin to your project
    kapt("androidx.room:room-compiler:$room_version")

    // If this project only uses Java source, use the Java annotationProcessor
    // No additional plugins are necessary
    annotationProcessor("androidx.room:room-compiler:$room_version")
    // optional - Kotlin Extensions and Coroutines support for Room
    implementation("androidx.room:room-ktx:$room_version")
    // optional - RxJava2 support for Room
    implementation("androidx.room:room-rxjava2:$room_version")
    // optional - RxJava3 support for Room
    implementation("androidx.room:room-rxjava3:$room_version")
    // optional - Guava support for Room, including Optional and ListenableFuture
    implementation("androidx.room:room-guava:$room_version")
    // optional - Test helpers
    testImplementation("androidx.room:room-testing:$room_version")
    // optional - Paging 3 Integration
    implementation("androidx.room:room-paging:$room_version")

    ////////////////////////////////
    // Coroutines support
    implementation(libs.kotlinx.coroutines.core)

    // Testing dependencies
    testImplementation(libs.junit)
    androidTestImplementation(libs.androidx.junit)
    androidTestImplementation(libs.androidx.espresso.core)

    //Compose dependencies
    implementation(libs.androidx.lifecycle.viewmodel.compose)
    implementation(libs.androidx.navigation.compose)
//    val compose_version = "1.6.7"
    implementation(libs.androidx.material.icons.extended)
    implementation(libs.androidx.hilt.navigation.compose)
}

kapt {
    correctErrorTypes = true
}


package com.example.apptest.feature_train.presentation.trainings

import androidx.compose.runtime.State
import androidx.compose.runtime.mutableStateOf
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.apptest.feature_train.domain.model.Training
import com.example.apptest.feature_train.domain.use_case.training_use_case.TrainingUseCases
import com.example.apptest.feature_train.domain.util.OrderType
import com.example.apptest.feature_train.domain.util.TrainingOrder
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.Job
import kotlinx.coroutines.flow.launchIn
import kotlinx.coroutines.flow.onEach
import kotlinx.coroutines.launch
import javax.inject.Inject


// used to inject a VM in a specific screen component
@HiltViewModel
class TrainingsViewModel @Inject constructor(
    private val trainingsUseCases: TrainingUseCases
    ): ViewModel(){

    private var recentlyDeletedTraining: Training? = null
    private var getTrainingsJob: Job? = null

    // state of this screen
    private val _state = mutableStateOf(TrainingsState())
    val state: State<TrainingsState> = _state

    init {
        getTrainings(TrainingOrder.Date(OrderType.Descending))
    }

    fun onEvent(event: TrainingsEvent){
        when(event){
            is TrainingsEvent.Order -> {
                // ::class is used to compare not equality of links, but of class types,
                // since trainorder is a class, not object like ordertype
                if (state.value.trainingOrder::class == event.trainingOrder::class &&
                    state.value.trainingOrder.orderType == event.trainingOrder.orderType)
                {
                    return
                }
                getTrainings(event.trainingOrder)
            }
            is TrainingsEvent.DeleteTraining -> {
                viewModelScope.launch {
                    trainingsUseCases.deleteTraining(event.training)
                    recentlyDeletedTraining = event.training
                }
            }
            is TrainingsEvent.RestoreTraining -> {
                viewModelScope.launch {
                    trainingsUseCases.addTraining(recentlyDeletedTraining ?: return@launch)
                    recentlyDeletedTraining = null
                }
            }
            // just hides and reveals order bttn
            is TrainingsEvent.ToggleOrderSection -> {
                _state.value = state.value.copy(
                    isOrderSectionVisible = !state.value.isOrderSectionVisible
                )
            }
        }
    }

    private fun getTrainings(trainingOrder: TrainingOrder){
        // if already trying to retrieve trainings from Dao, cancel attempt
        getTrainingsJob?.cancel()
        getTrainingsJob = trainingsUseCases.getAllTrainings(trainingOrder)
            .onEach {trainings ->
                _state.value = state.value.copy(
                    trainings = trainings,
                    trainingOrder = trainingOrder
                    // no selection of ordersection is specified, cause we wish to keep it consistent
                )
            }.launchIn(viewModelScope)
    }
}


package com.example.apptest.feature_train.presentation.trainings

import androidx.compose.animation.AnimatedVisibility
import androidx.compose.animation.ExperimentalAnimationApi
import androidx.compose.animation.fadeIn
import androidx.compose.animation.fadeOut
import androidx.compose.animation.slideInVertically
import androidx.compose.animation.slideOutVertically
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.PaddingValues
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.Sort
import androidx.compose.material.icons.filled.Add
import androidx.compose.material.icons.filled.Sort
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.FloatingActionButton
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Scaffold
import androidx.compose.material3.SnackbarHost
import androidx.compose.material3.SnackbarHostState
import androidx.compose.material3.SnackbarResult
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.navigation.NavController
import com.example.apptest.feature_train.presentation.trainings.components.OrderSection
import com.example.apptest.feature_train.presentation.trainings.components.TrainingItem
import com.example.apptest.feature_train.presentation.util.Screen
import kotlinx.coroutines.launch

@OptIn(ExperimentalAnimationApi::class, ExperimentalMaterial3Api::class)
@Composable
fun TrainingsScreen(
    navController: NavController,
    viewModel: TrainingsViewModel = hiltViewModel()
) {
    // assigned viewmodel state to local layout objects
    val state = viewModel.state.value
    val scaffoldState = remember { SnackbarHostState() }
    val scope = rememberCoroutineScope()

    Scaffold(
        floatingActionButton = {
            FloatingActionButton(
                onClick = {
                    //TODO: navigation is not implemented yet
//                    navController.navigate(Screen.AddEditTrainingScreen.route)
                },
                containerColor = MaterialTheme.colorScheme.primary
            ) {
                Icon(imageVector = Icons.Default.Add, contentDescription = "Add training")
            }
        },
        snackbarHost = { SnackbarHost(scaffoldState) }
    ) { innerPadding ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(innerPadding) // Apply the innerPadding provided by Scaffold
        ) {
            Row(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(16.dp),
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.CenterVertically
            ) {
                Text(
                    text = "Your trainings",
                    style = MaterialTheme.typography.headlineMedium
                )
                IconButton(
                    onClick = {
                        // changed the state of oredersection visibility to opposite
                        viewModel.onEvent(TrainingsEvent.ToggleOrderSection)
                    },
                ) {
                    Icon(
                        imageVector = Icons.AutoMirrored.Default.Sort,
                        contentDescription = "Sort"
                    )
                }
            }
            AnimatedVisibility(
                visible = state.isOrderSectionVisible,
                enter = fadeIn() + slideInVertically(),
                exit = fadeOut() + slideOutVertically()
            ) {
                OrderSection(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(16.dp),
                    trainingOrder = state.trainingOrder,
                    onOrderChange = {
                        // when any button of section pressed calls event in VM
                        viewModel.onEvent(TrainingsEvent.Order(it))
                    }
                )
            }
            Spacer(modifier = Modifier.height(16.dp))
            LazyColumn(modifier = Modifier.fillMaxSize().padding(horizontal = 16.dp)) {
                // takes trainings from outer, changed state
                items(state.trainings) { training ->
                    TrainingItem(
                        training = training,
                        modifier = Modifier
                            .fillMaxWidth()
                            .clickable {
                                //ToDo: navigation is not implemented yet
//                                navController.navigate(
//                                    Screen.AddEditTrainingScreen.route +
//                                            "?trainingId=${training.id}"
//                                )
                            },
                        onDeleteClick = {
                            viewModel.onEvent(TrainingsEvent.DeleteTraining(training))
                            scope.launch {
                                val result = scaffoldState.showSnackbar(
                                    message = "Training deleted",
                                    actionLabel = "Undo"
                                )
                                if (result == SnackbarResult.ActionPerformed) {
                                    viewModel.onEvent(TrainingsEvent.RestoreTraining)
                                }
                            }
                        }
                    )
                    Spacer(modifier = Modifier.height(16.dp))
                }
            }
        }
    }
}

